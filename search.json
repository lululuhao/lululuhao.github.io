[{"title":"L·H","url":"%2F2019%2F09%2F24%2FL%C2%B7H%2F","content":"\n**如果痴痴的等某日，终可等到一生中最爱。**\n","tags":["L·H"]},{"title":"装centos系统后必须要做的几件事！！！","url":"%2F2018%2F12%2F03%2F%E5%BC%80%E6%9C%BA%E5%90%8E%E5%BF%85%E9%A1%BB%E5%81%9A%E7%9A%84%E5%87%A0%E4%BB%B6%E4%BA%8B%2F","content":"\n\n\n\n定义习惯用的别名\n```bash\nvim .bashrc\nalias rm='rm -i'\nalias cp='cp -i'\nalias mv='mv -i'\nalias yy='yum install -y'\n```\n修改网卡信息,配置固定ip\n```bash\nvim /etc/sysconfig/network-scripts/ifcfg-ens33\nPREFIX=24\nBOOTPROTO=static\nIPADDR=192.168.245.7\nNAME=ens33\nDEVICE=ens33\nONBOOT=yes\n```\n修改默认颜色\n```bash\nvim /etc/profile.d/env.sh\nPS1=\"\\[\\e[1;32m\\][\\u@\\h \\W]\\\\$\\[\\e[0m\\]\"\n```\n修改欢迎界面\n```bash\nvim /etc/motd   #打开配置文件,复制下面的字符\n\n                                                     /*[*/#include<stdio.h>//\n                         #include<stdlib.h>//]++++[->++[->+>++++<<]<][(c)2013]\n                        #ifndef                                           e//[o\n                       #include<string.h>//]![misaka.c,size=3808,crc=d0ec3b36][\n                      #define e                                           0x1//\n                     typedef struct{int d,b,o,P;char*q,*p;}f;int p,q,d,b,_=0//|\n                  #include __FILE__//]>>>[->+>++<<]<[-<<+>>>++<]>>+MISAKA*IMOUTO\n                #undef e//[->[-<<+<+<+>>>>]<<<<<++[->>+>>>+<<<<<]>+>+++>+++[>]]b\n             #define e(c)/**/if((_!=__LINE__?(_=__LINE__):0)){c;}//[20002,+[-.+]\n            ,O,i=0,Q=sizeof(f);static f*P;static FILE*t;static const char*o[]={//\n          \"\\n\\40\\\"8oCan\\40not\\40open %s\\n\\0aaFbfeccdeaEbgecbbcda6bcedd#e(bbed$bbd\",\n        \"a6bgcdbbccd#ead$c%bcdea7bccde*b$eebbdda9bsdbeccdbbecdcbbcceed#eaa&bae$cbe\",\n       \"e&cbdd$eldbdeedbbdede)bdcdea&bbde1bedbbcc&b#ccdee&bdcdea'bbcd)e'bad(bae&bccd\",\n      \"e&bbda1bdcdee$bbce#b$c&bdedcd%ecdca4bhcdeebbcd#e$b#ecdcc$bccda7bbcc#e#d%c*bbda\",\n     \">bad/bbda\"};static int S(){return(o[p][q]);}static/**/int/**/Z=0  ;void/**/z(int//\n    l){if(/**/Z-l){Z=l;q++;if(p<b*5&&!S()){p+=b;q=0;}}}int main(int I,    /**/char**l){//\n   d=sizeof(f*);if(1<(O=_)){b=((sizeof(o)/sizeof(char*))-1)/4;q=22; p=     0;while(p<b*5){\n  /*<*/if(Z-1){d=S()>96;i=S()-(d?96:32) ;q++;if(p<b*5&&!S()){p+=b;  q=      0;}Z=1;}/*[[*/\n  while(i){_=o[0][S()-97];I=_-10?b:1;   for( ;I--;)putchar(_ );if   (!      --i||d)z(~i );}\n if(p==b*5&&O){p-=b;O--;}}return 0U;   }if(! (P=( f*)calloc /*]*/  (Q        ,I)))return 1;\n {;}for(_=p=1;p<I;p++){e(q=1);while    (q<   p&&  strcmp(  l[p     ]         ,l[(q)]))++  q;\n t=stdin;if(q<p){(void)memcpy/* \"      */    (&P  [p],&P   [q     ]          ,Q);continue ;}\nif(strcmp(l[p],\"-\")){t=fopen(l         [     p]   ,\"rb\"   )                  ;if(!t ){{;}  ;\nprintf(05+*o,l[p ]);return+1;                      {;}                       }}_=b= 1<<16   ;\n*&O=5;do{if(!(P[p].q=realloc   (P[p].q,(P[p].P     +=       b)+1))){return   01;}O   &=72   /\n6/*][*/;P[p].o+=d=fread(P[p]      .q       +P[     p           ].       o,  1,b,t)   ;}//\n while(d==b)      ;P [p].q[       P[       p]                  .o       ]=  012;d    =0;\n e(fclose(t        )  );P         [p]      .p                  =P[      p]  .q;if    (O)\n {for(;d<P[            p]          .o     ;d=                   q+     1)    {q=     d;\n  while(q<P[                        p].o&&P[                    p].q[q]-     10     ){\n  q++;}b=q-d;                         _=P                         [p].        d     ;\n  if(b>_){/*]b                                                                */\n   P[p].d=b;}{;                                                                }\n   #undef/*pqdz'.*/  e//                                                      ;\n   #define/*s8qdb]*/e/**/0                                                   //\n   //<<.<<.----.>.<<.>++.++<                                              .[>]\n   /*P[*/P[p].b++;continue;}}}t=                                       stdout;\n  for (p=1;p<I;p++){/**/if(P[p].b>i                               ){i=P[p].b;}}\n if  (O){for(p=0;p<i;p++){q=0;/*[*/while(I               >++q){_=P[q].p-P[q ].q;\nb=   0;if(_<P[q ].o){while(012-*P[q].p)     {putchar(*(P[q].p++));b++;}P[q]. p++;\n}   ;while (P[  q].d>b++)putchar(040);}             putchar(10);}return 0;}p   =1;\n   for(;   p<I   ;p++)fwrite(P[p] .q,P[              p].o,1,t);return 0 ;}//\n  #/*]     ]<.    [-]<[-]<[- ]<[    -]<               [-  ]<;*/elif  e    //b\n |(1        <<     ( __LINE__        /*               >>   `*//45))  |     01U\n             #                       /*               */     endif            //\n\n\n```\n\n修改vim编辑器提示信息\n```bash\nvim /etc/vimrc\nhi comment ctermfg=6  #注释变为淡蓝色\nset nu   #vim编辑器里出现行号\nsyntax on  #语法高亮\nset ignorecase        #搜索模式里忽略大小写\n\nvim .vimrc   #优先生效\nset ignorecase                                                                                                                                                 \nset cursorline   #设置下划线\nset autoindent\nautocmd BufNewFile *.sh exec \":call SetTitle()\"\nfunc SetTitle()\n        if expand(\"%:e\") == 'sh'\n        call setline(1,\"#!/bin/bash\")\n        call setline(2,\"#\")\n        call setline(3,\"#********************************************************************\")\n        call setline(4,\"#Author:                LH\")\n         call setline(5,\"#QQ:                    501962149\")\n        call setline(6,\"#Date:                  \".strftime(\"%Y-%m-%d\"))\n       call setline(7,\"#FileName：             \".expand(\"%\"))\n         call setline(8,\"#URL:                   https://blog.csdn.net/weixin_43551152\")\n         call setline(9,\"#Description：          今晚打老虎\")\n         call setline(10,\"#Copyright (C):        \".strftime(\"%Y\").\" All rights reserved\")\n        call setline(11,\"#********************************************************************\")\n        call setline(12,\"\")\n        endif\n endfunc\nautocmd BufNewFile * normal G\n```\n\n指定yum源，base源和epel源\nctneos6    base源\n```bash\nyum install -y autofs      #设置/misc/cd神奇目录自动挂载\nchkconfig autofs on    #设置autofs服务开机启动\nvim /etc/yum.repos.d/Centos-6.repo   #base源\n[base]\nname=CentOS- Base-cdrom                                                                                                                                        \nfailovermethod=priority\nbaseurl=file:///misc/cd\ngpgcheck=0\n  ```\n ctneos6   epel源\n ```bash\nvim /etc/yum.repos.d/epel.repo     #epel源\n [epel]\nname=Extra Packages for Enterprise Linux 6 - $basearch\nbaseurl=https://mirrors.tuna.tsinghua.edu.cn/epel/6/$basearch\n#mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=epel-7&arch=$basearch\nfailovermethod=priority\nenabled=1\ngpgcheck=1\ngpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-6\n```\n\n\n    \nctneos7   base源\n```bash\nyum install -y autofs      #设置/misc/cd神奇目录自动挂载\nsystemctl enable autofs       #设置autofs服务开机启动\nvim /etc/yum.repos.d/Centos-7.repo  #base源\n[base]\nname=CentOS-$releasever - Base -sr0--\nfailovermethod=priority\nbaseurl=file:///data/cdrom\ngpgcheck=0\n```\n\nctneos7   epel源\n```bash\nvim /etc/yum.repos.d/epel.repo   #epel源\n[epel]\nname=Extra Packages for Enterprise Linux 7 - $basearch\nbaseurl=https://mirrors.tuna.tsinghua.edu.cn/epel/7/$basearch\n#mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=epel-7&arch=$basearch\nfailovermethod=priority\nenabled=1\ngpgcheck=1\ngpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7\n~    \n```\n修改ssh协议默认端口\n```bash\nvim /etc/ssh/sshd_config  \n#Port 22 \nPort 10086    #  修改默认端口   \nsystemctl restart sshd.service\n```\n\n安装防火墙\n```bash\nyum install firewalld\nsystemctl start firewalld\n```\n\n计划任务设置自动更新\n```bash\nyum -y install yum-cron    \nvim /etc/yum/yum-cron.conf\napply_updates = yes   #no改为yes\nsystemctl start crond\nsystemctl start yum-cron  \n```\n\n安装py3.6\n```bash\nyum install python36      \ncd /usr/bin/      \nrm python       \nln -s python3.6 python    \n将yum的解析器改为Python2.7\nvim /usr/bin/yum\n#!/usr/bin/python2.7  #改第一行\nvim /usr/libexec/urlgrabber-ext-down\n#!/usr/bin/python2.7  #改第一行\n \nyum install python36-pip          \n```","tags":["L·H"]},{"title":"各种小工具和小玩意，小火车，黑客代码，国际象棋盘，三角形","url":"%2F2018%2F11%2F11%2F%E5%90%84%E7%A7%8D%E5%B0%8F%E5%B7%A5%E5%85%B7%E5%92%8C%E5%B0%8F%E7%8E%A9%E6%84%8F%EF%BC%8C%E5%B0%8F%E7%81%AB%E8%BD%A6%EF%BC%8C%E9%BB%91%E5%AE%A2%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E7%9B%98%EF%BC%8C%E4%B8%89%E8%A7%92%E5%BD%A2%2F","content":"\n\n# 笔记本电脑查询已连接WIFI密码\n###本方法适用于忘了WiFi密码或者通过其他手段连上WiFi却不知道密码的\n```bash\n#按Windows+R，输入cmd启动命令行\n#命令行中输入\nnetsh wlan show profiles   #列出已保存WiFi\nnetsh wlan show profiles name=12345 key=clear \n#即可查询WiFi名称为12345的密码，在安全设置中，密码即为下方关键内容\n```\n\n# Linux下取出指定位的随机密码\n```bash\ncat /dev/urandom |tr -dc 'a-zA-Z0-9_' |head -c12 #取出12位的随机密码，尾数改变改为8即取8位\n```\n\n# Linux命令颜色和欢迎界面！\n在全局设置中写入配置\n\n### 字体颜色和背景设置\n\n```bash\nvim /etc/profile.d/env.sh   #打开配置文件\nPS1=\"\\[\\e[1;32m\\][\\u@\\h \\W]\\\\$\\[\\e[0m\\]\"\n#按esc，然后输入wq保存，重新登陆客户端即可\n```\n如图\n![111](https://img-blog.csdnimg.cn/20181101113754610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MTE1Mg==,size_16,color_FFFFFF,t_70)\n![1112](https://img-blog.csdnimg.cn/20181101113811394.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MTE1Mg==,size_16,color_FFFFFF,t_70)\n可以看到上面两图命令颜色变成了绿色\n那么欢迎界面怎么设置呢？\n## 欢迎界面\n```bash\nvim /etc/motd   #打开配置文件,复制下面的字符\n\n                                                     /*[*/#include<stdio.h>//\n                         #include<stdlib.h>//]++++[->++[->+>++++<<]<][(c)2013]\n                        #ifndef                                           e//[o\n                       #include<string.h>//]![misaka.c,size=3808,crc=d0ec3b36][\n                      #define e                                           0x1//\n                     typedef struct{int d,b,o,P;char*q,*p;}f;int p,q,d,b,_=0//|\n                  #include __FILE__//]>>>[->+>++<<]<[-<<+>>>++<]>>+MISAKA*IMOUTO\n                #undef e//[->[-<<+<+<+>>>>]<<<<<++[->>+>>>+<<<<<]>+>+++>+++[>]]b\n             #define e(c)/**/if((_!=__LINE__?(_=__LINE__):0)){c;}//[20002,+[-.+]\n            ,O,i=0,Q=sizeof(f);static f*P;static FILE*t;static const char*o[]={//\n          \"\\n\\40\\\"8oCan\\40not\\40open %s\\n\\0aaFbfeccdeaEbgecbbcda6bcedd#e(bbed$bbd\",\n        \"a6bgcdbbccd#ead$c%bcdea7bccde*b$eebbdda9bsdbeccdbbecdcbbcceed#eaa&bae$cbe\",\n       \"e&cbdd$eldbdeedbbdede)bdcdea&bbde1bedbbcc&b#ccdee&bdcdea'bbcd)e'bad(bae&bccd\",\n      \"e&bbda1bdcdee$bbce#b$c&bdedcd%ecdca4bhcdeebbcd#e$b#ecdcc$bccda7bbcc#e#d%c*bbda\",\n     \">bad/bbda\"};static int S(){return(o[p][q]);}static/**/int/**/Z=0  ;void/**/z(int//\n    l){if(/**/Z-l){Z=l;q++;if(p<b*5&&!S()){p+=b;q=0;}}}int main(int I,    /**/char**l){//\n   d=sizeof(f*);if(1<(O=_)){b=((sizeof(o)/sizeof(char*))-1)/4;q=22; p=     0;while(p<b*5){\n  /*<*/if(Z-1){d=S()>96;i=S()-(d?96:32) ;q++;if(p<b*5&&!S()){p+=b;  q=      0;}Z=1;}/*[[*/\n  while(i){_=o[0][S()-97];I=_-10?b:1;   for( ;I--;)putchar(_ );if   (!      --i||d)z(~i );}\n if(p==b*5&&O){p-=b;O--;}}return 0U;   }if(! (P=( f*)calloc /*]*/  (Q        ,I)))return 1;\n {;}for(_=p=1;p<I;p++){e(q=1);while    (q<   p&&  strcmp(  l[p     ]         ,l[(q)]))++  q;\n t=stdin;if(q<p){(void)memcpy/* \"      */    (&P  [p],&P   [q     ]          ,Q);continue ;}\nif(strcmp(l[p],\"-\")){t=fopen(l         [     p]   ,\"rb\"   )                  ;if(!t ){{;}  ;\nprintf(05+*o,l[p ]);return+1;                      {;}                       }}_=b= 1<<16   ;\n*&O=5;do{if(!(P[p].q=realloc   (P[p].q,(P[p].P     +=       b)+1))){return   01;}O   &=72   /\n6/*][*/;P[p].o+=d=fread(P[p]      .q       +P[     p           ].       o,  1,b,t)   ;}//\n while(d==b)      ;P [p].q[       P[       p]                  .o       ]=  012;d    =0;\n e(fclose(t        )  );P         [p]      .p                  =P[      p]  .q;if    (O)\n {for(;d<P[            p]          .o     ;d=                   q+     1)    {q=     d;\n  while(q<P[                        p].o&&P[                    p].q[q]-     10     ){\n  q++;}b=q-d;                         _=P                         [p].        d     ;\n  if(b>_){/*]b                                                                */\n   P[p].d=b;}{;                                                                }\n   #undef/*pqdz'.*/  e//                                                      ;\n   #define/*s8qdb]*/e/**/0                                                   //\n   //<<.<<.----.>.<<.>++.++<                                              .[>]\n   /*P[*/P[p].b++;continue;}}}t=                                       stdout;\n  for (p=1;p<I;p++){/**/if(P[p].b>i                               ){i=P[p].b;}}\n if  (O){for(p=0;p<i;p++){q=0;/*[*/while(I               >++q){_=P[q].p-P[q ].q;\nb=   0;if(_<P[q ].o){while(012-*P[q].p)     {putchar(*(P[q].p++));b++;}P[q]. p++;\n}   ;while (P[  q].d>b++)putchar(040);}             putchar(10);}return 0;}p   =1;\n   for(;   p<I   ;p++)fwrite(P[p] .q,P[              p].o,1,t);return 0 ;}//\n  #/*]     ]<.    [-]<[-]<[- ]<[    -]<               [-  ]<;*/elif  e    //b\n |(1        <<     ( __LINE__        /*               >>   `*//45))  |     01U\n             #                       /*               */     endif            //\n\n#按esc，然后输入wq保存，重新登陆客户端即可\n```\n或者复制这个\n```\n▽\n                              _.._        ,------------.                                                        \n                           ,'      `.    ( I want you! )\n                          /  __) __` \\    `-,----------'\n                         (  (`-`(-')  ) _.-'\n                         /)  \\  = /  (\n                        /'    |--' .  \\\n                       (  ,---|  `-.)__`\n                        )(  `-.,--'   _`-.\n                       '/,'          (  Uu\",\n                        (_       ,    `/,-' )\n                        `.__,  : `-'/  /`--'\n                          |     `--'  |\n                          `   `-._   /\n                           \\        (\n                           /\\ .      \\.\n                          / |` \\     ,-\\\n                         /  \\| .)   /   \\\n                        ( ,'|\\    ,'     :\n                        | \\,`.`--\"/      }\n                        `,'    \\  |,'    /\n                       / \"-._   `-/      |\n                       \"-.   \"-.,'|     ;\n                      /        _/[\"---'\"\"]\n                     :        /  |\"-     '\n                     '           |      /\n                                 `      |\n~                                         \n```\n\n\n# 在centos下用cmatrix做出×××屏幕代码雨效果\n文章出处：\n\nhttp://blog.51cto.com/5232821/2146115      作者：hubbywen0\n**1、下载cmatrix-1.2a.tar.gz文件**\n```bash\n[root@localhost ~]# wget https://jaist.dl.sourceforge.net/project/cmatrix/cmatrix/1.2a/cmatrix-1.2a.tar.gz    #centos 下载不了此安装包，需自行下载到本地，rz上传到Linux系统\n--2018-07-17 15:06:03--  https://jaist.dl.sourceforge.net/project/cmatrix/cmatrix/1.2a/cmatrix-1.2a.tar.gz\nResolving jaist.dl.sourceforge.net (jaist.dl.sourceforge.net)... 150.65.7.130, 2001:df0:2ed:feed::feed\nConnecting to jaist.dl.sourceforge.net (jaist.dl.sourceforge.net)|150.65.7.130|:443... connected.\nHTTP request sent, awaiting response... 200 OK\nLength: 74376 (73K) [application/x-gzip]\nSaving to: ‘cmatrix-1.2a.tar.gz’\n\n100%[=====================================================>] 74,376      4.68KB/s   in 16s    \n\n2018-07-17 15:06:20 (4.68 KB/s) - ‘cmatrix-1.2a.tar.gz’ saved [74376/74376]\n```\n**2、解压缩cmatrix-1.2a.tar.gz文件**\n```bash\n\n[root@localhost ~]# tar xvf cmatrix-1.2a.tar.gz\ncmatrix-1.2a/\ncmatrix-1.2a/NEWS\ncmatrix-1.2a/TODO\ncmatrix-1.2a/aclocal.m4\ncmatrix-1.2a/README\ncmatrix-1.2a/configure\ncmatrix-1.2a/configure.in\ncmatrix-1.2a/cmatrix.1\ncmatrix-1.2a/cmatrix.c\ncmatrix-1.2a/config.guess\ncmatrix-1.2a/install-sh\ncmatrix-1.2a/cmatrix.spec\ncmatrix-1.2a/cmatrix.spec.in\ncmatrix-1.2a/matrix.fnt\ncmatrix-1.2a/config.sub\ncmatrix-1.2a/missing\ncmatrix-1.2a/mkinstalldirs\ncmatrix-1.2a/Makefile.am\ncmatrix-1.2a/Makefile.in\ncmatrix-1.2a/mtx.pcf\ncmatrix-1.2a/config.h.in\ncmatrix-1.2a/matrix.psf.gz\ncmatrix-1.2a/stamp-h.in\ncmatrix-1.2a/AUTHORS\ncmatrix-1.2a/INSTALL\ncmatrix-1.2a/ChangeLog\ncmatrix-1.2a/acconfig.h\ncmatrix-1.2a/COPYING\n```\n```bash\n[root@localhost ~]# cd cmatrix-1.2a\n\n[root@localhost cmatrix-1.2a]# yum install ncurses-deve\n```\n```bash\n[root@bogon cmatrix-1.2a]# ./configure && make && make install\nloading cache ./config.cache\nchecking for a BSD compatible install... /usr/bin/install -c\nchecking whether build environment is sane... yes\nchecking whether make sets ${MAKE}... yes\nchecking for working aclocal... missing\nchecking for working autoconf... missing\nchecking for working automake... missing\nchecking for working autoheader... missing\nchecking for working makeinfo... missing\nchecking for gcc... no\nchecking for cc... no\nconfigure: error: no acceptable cc found in $PATH\n\n当执行“./configure && make && make install ”命令出现如上信息时，表示没有安装gcc，gcc安装过程如下\n[root@bogon cmatrix-1.2a]# yum -y install gcc\n[root@bogon cmatrix-1.2a]# yum -y install gcc-c++\n[root@bogon cmatrix-1.2a]# yum install make\n\n安装完后再运行“./configure && make && make install ”命令，如下：\n[root@localhost cmatrix-1.2a]# ./configure && make && make install\ncreating cache ./config.cache\nchecking for a BSD compatible install... /usr/bin/install -c\nchecking whether build environment is sane... yes\nchecking whether make sets ${MAKE}... yes\nchecking for working aclocal... missing\nchecking for working autoconf... missing\nchecking for working automake... missing\nchecking for working autoheader... missing\nchecking for working makeinfo... missing\nchecking for gcc... gcc\nchecking whether the C compiler (gcc  ) works... yes\nchecking whether the C compiler (gcc  ) is a cross-compiler... no\nchecking whether we are using GNU C... yes\nchecking whether gcc accepts -g... yes\nchecking for a BSD compatible install... /usr/bin/install -c\nchecking whether make sets ${MAKE}... (cached) yes\nchecking for main in -lncurses... yes\nchecking how to run the C preprocessor... gcc -E\nchecking for ANSI C header files... yes\nchecking for fcntl.h... yes\nchecking for sys/ioctl.h... yes\nchecking for unistd.h... yes\nchecking for termios.h... yes\nchecking for termio.h... yes\nchecking return type of signal handlers... void\nchecking for putenv... yes\nchecking for curses.h... yes\nchecking for ncurses.h... yes\nchecking for tgetent in -lncurses... yes\nUsing ncurses as the termcap library\nchecking for use_default_colors in -lncurses... yes\nchecking for resizeterm in -lncurses... yes\nchecking for wresize in -lncurses... yes\nchecking for consolechars... no\nchecking for setfont... /usr/bin/setfont\nchecking for /usr/lib/kbd/consolefonts... yes\nchecking for /usr/share/consolefonts... no\nchecking for mkfontdir... no\nchecking for /usr/lib/X11/fonts/misc... no\nchecking for /usr/X11R6/lib/X11/fonts/misc... no\nconfigure: warning:  \n\n*** You do not appear to have an X window fonts directory in the standard\n*** locations (/usr/lib/X11/fonts/misc or /usr/X11R6/lib/X11/fonts/misc). The\n*** mtx.pcf font will not be installed.  This means you will probably not\n*** be able to use the mtx fonts in your x terminals, and hence be unable\n*** to use the -x command line switch.  Sorry about that...\n\nupdating cache ./config.cache\ncreating ./config.status\ncreating Makefile\ncreating cmatrix.spec\ncreating config.h\ngcc -DHAVE_CONFIG_H -I. -I. -I.     -g -O2 -Wall -Wno-comment -c cmatrix.c\ngcc  -g -O2 -Wall -Wno-comment  -o cmatrix  cmatrix.o  -lncurses  -lncurses\nmake[1]: Entering directory `/root/cmatrix-1.2a'\n/bin/sh ./mkinstalldirs /usr/local/bin\n  /usr/bin/install -c  cmatrix /usr/local/bin/cmatrix\nmake  install-man1\nmake[2]: Entering directory `/root/cmatrix-1.2a'\n/bin/sh ./mkinstalldirs /usr/local/man/man1\nmkdir /usr/local/man\nmkdir /usr/local/man/man1\n/usr/bin/install -c -m 644 ./cmatrix.1 /usr/local/man/man1/cmatrix.1\nmake[2]: Leaving directory `/root/cmatrix-1.2a'\nInstalling matrix fonts in /usr/lib/kbd/consolefonts...\nmake[1]: Leaving directory `/root/cmatrix-1.2a'\n\n**到此，cmatrix安装完成，任意路径，输入cmatrix运行，按q退出。效果如下**\n[root@localhost cmatrix-1.2a]# cmatrix\n![](http://i2.51cto.com/images/blog/201807/17/abaa3c9ee4b6cf559c3db8173c2cd2bc.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=)\n\ncmatrix常用命令如下:\n-a :异步滚动（默认）\n-b :随机粗体\n-B :全部粗体\n-o :使用旧风格滚动\n-x :X window 模式\n-V :显示版本信息\n-u :刷新频率，0-9，也就是滚动的快慢（值越小越快）\n-C :显示的颜色，支持green(默认),red,blue,white,yellow,cyan,magenta and black\n\n[root@localhost ~]# cmatrix -b -u 3 -C yellow\n![](http://i2.51cto.com/images/blog/201807/17/4a2e39f2aa2889910d633b6bfb92d18f.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=)\n```\n\n# Linux上sl工具安装（小火车）\n\ncentos7上跑火车代码\n```bash\nwget http://mirror.centos.org/centos/7/extras/x86_64/Packages/epel-release-7-9.noarch.rpm\nyum install -y epel-release-7-9.noarch.rpm\nyum install -y sl\nsl   #运行程序\n```\ncentos6上跑火车代码\n```bash\nwget http://mirror.centos.org/centos-6/6.10/extras/x86_64/Packages/epel-release-6-8.noarch.rpm\nyum install -y epel-release-6-8.noarch.rpm\nyum install -y sl\nsl\n```\n结果如图：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20181101230105477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MTE1Mg==,size_16,color_FFFFFF,t_70)\n\n\n# 打出一个指定行与列的矩形，并使其边框闪烁\n如图：\n![矩形](https://img-blog.csdnimg.cn/20181106154559195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MTE1Mg==,size_16,color_FFFFFF,t_70)\n\n\n```bash\n#!/bin/bash\n#********************************************************************\nread -p \"please input colume: \"  col\nread -p \"please input line: \"  line\nfor i in `seq $line`;do\n        for j in `seq $col`;do\n                #if [ $i -eq 1 -o $i -eq $line -o $j -eq 1 -o $j -eq $col ];then\n                #如果当前行等于1或者等于行号line，或者当前列等于1或者等于列号col，则\n                #       COLOR=$[RANDOM%7+31]\n                #       echo -e \"\\033[1;5;${COLOR}m*\\033[0m\\c\"\n                #else\n                #       echo -e \"*\\c\"\n                #fi   以上方法为if语句，下面为case语句，都可实现\n                case $i in\n                1|$line)\n                        COLOR=$[RANDOM%7+31]\n                        echo -e \"\\033[1;5;${COLOR}m*\\033[0m\\c\"\n                        ;;\n                *)\n\n                        case $j in\n                        1|$col)\n                                COLOR=$[RANDOM%7+31]\n                                echo -e \"\\033[1;5;${COLOR}m*\\033[0m\\c\"\n                                ;;\n                        *)\n                                echo -e \"*\\c\" \n                        esac\n                esac\n        done\n        echo \ndone\n```\n\n# 实验：输入一个行号，打印一个等腰三角形\n如图：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20181106160700716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MTE1Mg==,size_16,color_FFFFFF,t_70)\n\n```bash\n#!/bin/bash\n#********************************************************************\nread -p \"Please input line: \" line\nfor i in `seq $line`;do\n        let star=$i*2-1\n        let space=$line-$i\n        for j in `seq $space`;do\n                echo -n \" \"\n        done\n        for k in `seq $star`;do\n                echo -n \"*\"\n        done\n        echo\ndone\n```\n# 选菜菜单\n \nPS3=\"Please input a number:\"\nselect MENU in lamian huimian gaifan jiaozi baozi quit;do\n        case $REPLY in\n        1|2)\n                echo \"The price is 15元\"\n                ;;\n        3|5)\n                echo \"The price is 20元\"\n                ;;\n        4)\n                echo \"The price is 25元\"\n        ;;\n        6)\n                echo \"bye\"\n                break\n                ;;\n        *)\n                echo \"Input false\"\n        esac\ndone\n\n# 九九乘法表\n打印出九九乘法表\n例如\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20181106161952387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MTE1Mg==,size_16,color_FFFFFF,t_70)\n```bash\nfor i in {1..9};do\n    for j in $(seq $i);do\n        echo -en \"${i}X${j}=$[$i*$j]\\t\"\n    done\n    echo\ndone\n```\n\n# 打印出国际象棋棋盘\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20181106162358832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MTE1Mg==,size_16,color_FFFFFF,t_70)\n```bash\n#！bin/bash\nfor i in {1..8};do\n    for j in {1..8};do\n        flag=$[(j+i)%2]\n        if [ $flag -eq 0 ];then\n            echo -e \"\\033[47m  \\033[0m\\c\"\n        else\n            echo -e \"  \\c\"\n        fi\n    done\n    echo\ndone\n```\n\n\n\n\n\n\n\n","tags":["L·H"]},{"title":"谷歌chrome浏览器自动启用flash","url":"%2F2018%2F11%2F08%2F%E8%B0%B7%E6%AD%8Cchrome%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E5%90%AF%E7%94%A8flash%2F","content":"\n新版的chrome浏览器不支持启用flash插件了，这也导致有时候打开视频或者微博上传图片时，浏览器提示你flash未启用或者版本过低，这时就算你再下载安装Adobe Flash Player也是不管用的。\n\n\n\n这时我们先去chrome实验室界面\n在地址栏输入：\n```\nchrome://flags/#enable-ephemeral-flash-permission\n```\n选择取消Disabled。取消该实验室选项，如下图：![在这里插入图片描述](https://img-blog.csdnimg.cn/20181108192236425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MTE1Mg==,size_16,color_FFFFFF,t_70)\n\n然后去在地址栏输入： \n```\nchrome://settings/content/flash \n```\n在下面的允许选项添加\n```\nhttp://*\nhttps://*\n```\n如图：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20181108192520934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MTE1Mg==,size_16,color_FFFFFF,t_70)\n并且退出浏览器之后不会不保存，Flash选项。\n此时重启浏览器，你就发现微博上传图片就可以正常使用了\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20181108192648655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MTE1Mg==,size_16,color_FFFFFF,t_70)","tags":["L·H"]},{"title":"shell防止黑客攻击","url":"%2F2018%2F10%2F21%2Fshell%E9%98%B2%E6%AD%A2%E9%BB%91%E5%AE%A2%E6%94%BB%E5%87%BB%2F","content":"\n# shell防止黑客攻击\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20181106170929109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MTE1Mg==,size_16,color_FFFFFF,t_70)\n```bash\n#!bin/bash\n#********************************************************************\nwhile : ;do\n        iplist=`who | sed -rn '/^cracker/s/.*\\((.*)\\)/\\1/p'`    #取出以cracker开头的黑客IP地址\n        if [ \"$iplist\" ] ;then\n                pkill -9 -U cracker \n                echo \"cracker is killed\"\n                echo sshd:$iplist >> /etc/hosts.deny    #将拦截的IP放到配置文件中，禁止下次连接\n        fi\n        sleep  10\ndone\n```","tags":["L·H"]},{"title":"批量ping IP脚本","url":"%2F2018%2F10%2F20%2F%E6%89%B9%E9%87%8Fping%20IP%E8%84%9A%E6%9C%AC%2F","content":"\n\n# 批量ping一个网络ID中的254个IP地址，并把能够Ping通的地址放到：/tmp/iplist.log\n\n例如ping百度的IP：123.125.115.110\nbash scanip00.sh  输入正确格式的IP地址\n![ping](https://img-blog.csdnimg.cn/20181106152508960.png)\ncat /tmp/iplist.log\n结果\n![能够Ping通的IP](https://img-blog.csdnimg.cn/20181106152703455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MTE1Mg==,size_16,color_FFFFFF,t_70)\n\n```bash\n#********************************************************************\n#scanip00.sh    # 脚本名\n> /tmp/iplist.log   #每次运行前清空该文件内容\nread -p \"Please input a netid:(eg:192.168.34.0) \" netid  #输入IP\nnetid=`echo $netid | sed -nr 's#(.*)\\..*#\\1#p'`\necho netid=$netid\nfor id in {1..254};do\n        {\n        if ping -c1 -w1  $netid.$id &>/dev/null ;then\n                echo \"$netid.$id\" >> /tmp/iplist.log  #ping通的放入文件\n                echo $netid.$id is up\n        else \n                echo $netid.$id is down\n        fi\n        }&                  #并行执行\ndone\nwait\n```","tags":["L·H"]},{"title":"shell脚本进阶和条件语句","url":"%2F2018%2F10%2F19%2Fshell%E8%84%9A%E6%9C%AC%E8%BF%9B%E9%98%B6%E5%92%8C%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%2F","content":"\n\n# if语句\n单分支\nif 判断条件;then\n条件为真的分支代码\nfi\n双分支\nif 判断条件; then\n条件为真的分支代码\nelse\n条件为假的分支代码\nfi\n多分支\nif 判断条件1; then\n条件1为真的分支代码\nelif 判断条件2; then\n条件2为真的分支代码\nelif 判断条件3; then\n条件3为真的分支代码\nelse\n以上条件都为假的分支代码\nfi\n## if示例\n根据命令的退出状态来执行命令\n```bash\nif ping -c1 -W2 station1 &> /dev/null; then\necho 'Station1 is UP'\nelif grep \"station1\" ~/maintenance.txt &> /dev/null; then\necho 'Station1 is undergoing maintenance‘\nelse\necho 'Station1 is unexpectedly DOWN!'\nexit 1\nfi\n```\n\n# case语句\n```bash\ncase 变量引用 in\nPAT1)\n分支1\n;;\nPAT2)\n分支2\n;;\n...\n*)\n默认分支\n;;\nesac\ncase支持glob风格的通配符：\n*: 任意长度任意字符\n?: 任意单个字符\n[]：指定范围内的任意单个字符\na|b: a或b\n```\n\n### 选菜菜单\n```bash\ncase $number in\n1|2|3)\ncmd1\n;;\n4|5|6)\ncmd1\n;;\n...\n*)\ncmd6\nesac\ncase脚本\ncat  <<EOF\n1:lamian\n2:gaifan\n3:jiaozi\n4:baozi\nEOF\n```\n```bash\n# 选菜菜单  vim xuancai.sh\nPS3=\"Please input a number:\"\nselect MENU in lamian huimian gaifan jiaozi baozi quit;do\n        case $REPLY in\n        1|2)\n                echo \"The price is 15元\"\n                ;;\n        3|5)\n                echo \"The price is 20元\"\n                ;;\n        4)\n                echo \"The price is 25元\"\n        ;;\n        6)\n                echo \"bye\"\n                break\n                ;;\n        *)\n                echo \"Input false\"\n        esac\ndone\n```\n**执行命令**\nbash xuancai.sh\n\n```bash\nread -p \"Please choose menu num: \" menu\ncase $menu in\n1|2）\n    echo \"lamian gaifan 15元 \"\n;;\n3|4)\n    echo \"jiaozi baozi 10元\"\n;;\n*)\necho \"wrong\"\n```\n例如：\n```bash\nread -p \"Do you agree(yes or no)? \" ans\nans= 'echo \"$ans|tr 'a-z' 'A-Z'\" '\ncase $ans in\ny|yes)\necho yes\n;;\nn|no)\necho no\n*)\necho wrong\n;;\nesac  \n```\n\n\n# 循环\nfor适用于有列表的循环\nwhile适合没有列表的循环，比较通用\nuntil与while条件相反\n\n\n## for循环\nfor 变量名 in 列表;do\n循环体\ndone\n执行机制：\n依次将列表中的元素赋值给“变量名”; 每次赋值后即执行一次循环体; 直\n到列表中的元素耗尽，循环结束\nfor特殊格式\n双小括号方法，即((…))格式，也可以用于算术运算\n双小括号方法也可以使bash Shell实现C语言风格的变量操作\nI=10\n((I++))\nfor循环的特殊格式：\nfor ((控制变量初始化;条件判断表达式;控制变量的修正表达式))\ndo\n循环体\ndone\n控制变量初始化：仅在运行到循环代码段时执行一次\n控制变量的修正表达式：每轮循环结束会先进行控制变量修正运算，而后再做\n条件判断\n```bash\nfor     ;do\n      for    ;do\n         if        ;then\n             continue,break(默认1,2为退出，执行外层循环)\n         fi\n      done\n```\n```bash\ndone\nlastb  查询其他人登陆失败的信息\n&> /dev/null  #将输出结果扔到垃圾箱，不在屏幕显示\n防止dos攻击，将攻击的ip地址放到/data/cracker_ip.log中\nnetstat -nat|sed -nr '/^tcp /s/.*  ([1-9].*):.*/\\1/p'|sort  |uniq -c |while read iplist ;do\n        linknum=`echo $iplist|cut -d\" \" -f1`\n        ip=`echo $iplist|cut -d\" \" -f2`\n        if [ $linknum -ge 2 ];then\n                echo $ip >> /data/cracker_ip.log\n        fi\ndone\n```\n```bash\n#!/bin/bash\n# 象棋方块\nfor i in {1..8};do\n        temp1=$[ $i % 2 ]\n\n        for j in {1..8};do\n        temp2=$[ $j % 2 ]\n\n        if [ $temp1 -eq  $temp2  ];then\n                echo -e -n \"\\033[47m  \\033[0m\"\n        else\n                echo -e -n \"\\033[41m  \\033[0m\"\n        fi\n\n        done\n\n        echo \ndone\n```\n\n### 实验：输入一个行号，打印一个等腰三角形\n如图：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20181106160700716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MTE1Mg==,size_16,color_FFFFFF,t_70)\n\n```bash\n#!/bin/bash\n#********************************************************************\nread -p \"Please input line: \" line\nfor i in `seq $line`;do\n        let star=$i*2-1\n        let space=$line-$i\n        for j in `seq $space`;do\n                echo -n \" \"\n        done\n        for k in `seq $star`;do\n                echo -n \"*\"\n        done\n        echo\ndone\n```\n\n### 批量ping一个网络ID中的254个IP地址，并把能够Ping通的地址放到：/tmp/iplist.log\n例如ping百度的IP：123.125.115.110\nbash scanip00.sh  输入正确格式的IP地址\n![ping](https://img-blog.csdnimg.cn/20181106152508960.png)\ncat /tmp/iplist.log\n结果\n![能够Ping通的IP](https://img-blog.csdnimg.cn/20181106152703455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MTE1Mg==,size_16,color_FFFFFF,t_70)\n**代码**\n```bash\n#********************************************************************\n#scanip00.sh    # 脚本名\n> /tmp/iplist.log   #每次运行前清空该文件内容\nread -p \"Please input a netid:(eg:192.168.34.0) \" netid  #输入IP\nnetid=`echo $netid | sed -nr 's#(.*)\\..*#\\1#p'`\necho netid=$netid\nfor id in {1..254};do\n        {\n        if ping -c1 -w1  $netid.$id &>/dev/null ;then\n                echo \"$netid.$id\" >> /tmp/iplist.log  #ping通的放入文件\n                echo $netid.$id is up\n        else \n                echo $netid.$id is down\n        fi\n        }&                  #并行执行\ndone\nwait\n```\n\n**计算从1加到100**\necho {1..100}|tr ' ' +|bc   管道计算得出5050\n或者写一个脚本\nsum.sh\nsum=0\nfor i in {1..100};do\nlet sum=sum+i\ndone\necho sum=$sum\nbash sum.sh  得出5050\n\n## while循环\nwhile CONDITION; do\n循环体\ndone\nCONDITION：循环控制条件；进入循环之前，先做一次判断；每一次循环之后\n会再次做判断；条件为“true”，则执行一次循环；直到条件测试状态为“false”\n终止循环\n因此：CONDTION一般应该有循环控制变量；而此变量的值会在循环体不断地被\n修正\n进入条件：CONDITION为true\n退出条件：CONDITION为false\n\n\n\n# 函数调用(function待整理)\n```bash\nversion(){\n        sed -nr 's/.* ([0-9]+)\\..*/\\1/p' /etc/centos-release\n}\nsysinfo(){\n        local name=wang\n        echo sysinfo:$name\n        echo Hostname is `hostname`\n        echo OS version is `version`\n}\nipaddr(){\n        ifconfig $1|sed -nr '2s/.*inet (addr:)?([^ ]+).*/\\2/p'\n}\nis_digit(){\n        [[ \"$1\" =~ ^[0-9]+$ ]] && true || false\n}\n```","tags":["L·H"]},{"title":"网络配置及route路由","url":"%2F2018%2F10%2F18%2F%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8Aroute%E8%B7%AF%E7%94%B1%2F","content":"\n# 修改主机名hostname\ncentos6 \nvim /etc/sysconfig/network 写入HOSTNAME=centos666.localdomain\nhostname centos666.localdomain\n最后exit退出或者exec bash刷新下缓存\n\ncentos7 设置主机名\nhostnamectl set-hostname centos777.localdomain\n最后exit退出或者exec bash刷新下缓存\n\n注：修改完成后最好将hosts里的主机名中添加新修改的主机名\nvim /etc/hosts \n在127回环地址后将加上修改的新主机名\n\n# ip和ifconfig的使用\nifconfig,route,netstat\nip:object{link,addr,route},ss,tc\nsysttem-config-network-tui,setup\nip a 查询网卡\nip addr add =ip a a 缩写\n例子：\n```bash\nip a a 1.1.1.1/24 dev eth0 #添加网卡地址\nipdown ipup 禁用启用网卡\nifconfig eth1 172.18.0.55/24\nifconfig eth1:2 172.18.0.60/24网卡别名，复制一个网卡，实现一个物理网卡绑定多个IP\nip addr del 1.1.1.1/24 dev eth0 #删除网卡地址\n```\nnetstat命令\n显示网络连接：\n```bash\nnetstat [--tcp|-t] [--udp|-u] [--raw|-w] [--listening|-l] [--all|-a] [--\nnumeric|-n] [--extend|-e[--extend|-e]] [--program|-p]\n-t: tcp协议相关\n-u: udp协议相关\n-w: raw socket相关\n-l: 处于监听状态\n-a: 所有状态\n-n: 以数字显示IP和端口\n-e：扩展格式\n-p: 显示相关进程及PID\n显示路由表：\nnetstat {--route|-r} [--numeric|-n]\n-r: 显示内核路由表\n-n: 数字格式\n显示接口统计数据：\nnetstat {--interfaces|-I|-i} [iface] [--all|-a] [--extend|-e] [--program|-p]\n[--numeric|-n]\nnetstat -i\nnetstat –I=IFACE\nifconfig -s eth0\n```\n\n```bash\nss\nss -nt 查询连接的用户\nss [OPTION]... [FILTER]\n netstat通过遍历proc来获取socket信息，ss使用netlink与内核tcp_diag模块通信获取socket信息。\n选项：\n-t: tcp协议相关\n-u: udp协议相关\n-w: 裸套接字相关\n-x：unix sock相关\n-l: listen状态的连接\n-a: 所有\n-n: 数字格式\n-p: 相关的程序及PID\n-e: 扩展的信息\n-m：内存用量\n-o：计时器信息\n常见用法\nss -l 显示本地打开的所有端口\nss -pl 显示每个进程具体打开的socket\nss -t -a 显示所有tcp socket\nss -u -a 显示所有的UDP Socekt\nss -o state established '( dport = :ssh or sport = :ssh )' 显示所有已建立的ssh连接\nss -o state established '( dport = :http or sport = :http )' 显示所有已建立的HTTP连接\nss -s 列出当前socket详细信息\n```\n\n\n\n# 网络配置文件\nIP、MASK、GW、DNS相关配置文件：/etc/sysconfig/network-\nscripts/ifcfg-IFACE\n路由相关的配置文件：\n>/etc/sysconfig/network-scripts/route-IFACE\n/etc/sysconfig/network-scripts/ifcfg-IFACE：\nDEVICE：此配置文件应用到的设备\nHWADDR：对应的设备的MAC地址\nBOOTPROTO：激活此设备时使用的地址配置协议，常用的dhcp, static,\nnone, bootp\nNM_CONTROLLED：NM是NetworkManager的简写，此网卡是否接受\nNM控制；建议CentOS6为“no”\nONBOOT：在系统引导时是否激活此设备\nTYPE：接口类型；常见有的Ethernet, Bridge\nUUID：设备的惟一标识\nIPADDR：指明IP地址\nNETMASK：子网掩码\nGATEWAY: 默认网关\nDNS1：第一个DNS服务器指向\nDNS2：第二个DNS服务器指向\nUSERCTL：普通用户是否可控制此设备\nPEERDNS：如果BOOTPROTO的值为“dhcp”，是否允许dhcp server分配的dns服务器指向信息直接覆盖至/etc/resolv.conf文件中\n\n\n# route路由\n```bash\nroute\n目标：192.168.1.1 网关：172.16.0.1\nroute add -default gw 192.168.1.1                                                          #添加默认路由\nroute add -host 192.168.1.6 gw 172.16.0.1 dev eth0                                       #添加主机路由\nroute add -net 192.168.1.6 netmask 255.255.255.0 gw 172.16.0.1 dev eth0   #添加网络路由\nroute add -net 192.168.1.6/24 gw 172.16.0.1 dev eth0                                   #添加网络路由  \nroute del 删除路由，同add\ntcpdump -nn icmp    抓包（IP地址）\ntcpdump -e -nn -s0   抓包（基于MAC地址）\nquagga 动态路由协议管理包\n```\n配置路由\n/etc/sysconfig/network-scripts/route-IFACE\n两种风格：\n(1) TARGET via GW\n如：10.0.0.0/8 via 172.16.0.1\n(2) 每三行定义一条路由\nADDRESS#=TARGET\nNETMASK#=mask\nGATEWAY#=GW\n\n\n# nmcli命令\n地址配置工具：nmcli\n```bash\nnmcli [ OPTIONS ] OBJECT { COMMAND | help }\ndevice - show and manage network interfaces\nnmcli device help\nconnection - start, stop, and manage network connections\nnmcli connection help\n修改IP地址等属性：\nnmcli connection modify IFACE [+|-]setting.property value\nsetting.property:\nipv4.addresses ipv4.gateway\nipv4.dns1 ipv4.method manual | auto\n修改配置文件执行生效：systemctl restart network\nnmcli con reload\nnmcli命令生效： nmcli con down eth0 ;nmcli con up eth0\n显示网络接口属性\nnmcli dev show eth0\n创建新连接default，IP自动通过dhcp获取\nnmcli con add con-name default type Ethernet ifname eth0\n删除连接\nnmcli con del default\n创建新连接static ，指定静态IP，不自动连接\nnmcti con add con-name static ifname eth0 autoconnect no type\nEthernet ipv4.addresses 172.25.X.10/24 ipv4.gateway 172.25.X.254\n修改连接设置\n```\n```bash\nnmcli con mod“static” connection.autoconnect no\nnmcli con mod “static” ipv4.dns 172.25.X.254\nnmcli con mod “static” +ipv4.dns 8.8.8.8\nnmcli con mod “static” -ipv4.dns 8.8.8.8\nnmcli con mod “static” ipv4.addresses “172.25.X.10/24 172.25.X.254”\nnmcli con mod “static” +ipv4.addresses 10.10.10.10/16\n```\n\n修改网卡的名称\nvim /etc/udev/rules.d/70-persistent-net.rules\n修改保存后要卸载网卡驱动才会生效\nethtool -i eth1 查询网卡的驱动\nmodprobe -r e1000 从内存中卸载网卡驱动，实际上硬件上的驱动没变化\nmodprobe e1000 装载网卡驱动\nreboot重启虚拟机生效\n以上方法只需要在cengos6上修改，centos7不需要\n原因：克隆虚拟机后MAC地址会被自动修改，与MAC地址对应的网卡名称也就需要修改了\n\n```bash\nscp -r wang@172.18.0.7:/data/script/ /data/  复制主机上文件\nssh wang@172.18.0.7  连接主机\n  tar -czvf beifen.tar.gz /data/script/*   将/data/script下的文件打包为beifen.tar.gz\n   sz beifen.tar.gz  将备份文件下载到Windows中，路径为C:\\Users\\Administrator\\Downloads\ntime bash *.sh 可以看出脚本运行需要多少时间\n```\n","tags":["L·H"]},{"title":"计划任务","url":"%2F2018%2F10%2F16%2F%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%2F","content":"计划任务\nLinux任务计划、周期性任务执行\n• 未来的某时间点执行一次任务\nat 指定时间点，执行一次性任务\nbatch 系统自行选择空闲时间去执行此处指定的任务\n• 周期性运行某任务\ncron\n\nat任务 (按ctrl+D保存)\n包：at\nat命令：at [option] TIME\n常用选项：\n\n-V 显示版本信息\n-t time 时间格式 [[CC]YY]MMDDhhmm[.ss]\n-l 列出指定队列中等待运行的作业；相当于atq\n-d 删除指定的作业；相当于atrm\n-c 查看具体作业任务\n-f /path/file 指定的文件中读取任务\n-m 当任务被完成之后，将给用户发送邮件，即使没有标准输出\n注意：作业执行命令的结果中的标准输出和错误以邮件通知给相关用户\nat时间格式\nHH:MM 02:00\n在今日的 HH:MM 进行，若该时刻已过，则明天此时执行任务\nHH:MM YYYY-MM-DD 02:00 2016-09-20\n规定在某年某月的某一天的特殊时刻进行该项任务\nHH:MM[am|pm] [Month] [Date]\n04pm March 17\n17:20 tomorrow\nHH:MM[am|pm] + number [minutes|hours|days|weeks]\n在某个时间点再加几个时间后才进行该项任务\nnow + 5 min\n02pm + 3 days\n\n计划任务cron\n放在/var/spool/cron/下\ncrontab -e 创建计划任务\n\n@reboot Run once after reboot\n@yearly 0 0 1 1 *\n@annually 0 0 1 1 *\n@monthly 0 0 1 * *\n@weekly 0 0 * * 0\n@daily 0 0 * * *\n@hourly 0 * * * *\n示例：每3小时echo和wall命令\n```bash\n0 */3 * * * centos /bin/echo “howdy”; wall “welcome to Magedu!”\netc/cron.hourly 下0anacron放着关机后未执行的计划任务，会在开机后一个合适的时间自动运行\netc/anacrontab记录了每天每周每月因关机未执行的计划任务自动执行的时间设置,配置文件：/etc/anacrontab，负责执行/etc/ cron.daily /etc/cron.weekly\n/etc/cron.monthly中系统任务\n```\n字段1：如果在这些日子里没有运行这些任务……\n• 字段2：在重新引导后等待这么多分钟后运行它\n• 字段3：任务识别器，在日志文件中标识\n• 字段4：要执行的任务\ncrontab命令：\n\ncrontab [-u user] [-l | -r | -e] [-i]\n```bash\n-l 列出所有任务\n-e 编辑任务\n-r 移除所有任务\n-I 同-r一同使用，以交互式模式移除指定任务\n-u user 仅root可运行，指定用户管理cron任务\n```\n控制用户执行计划任务：\n/etc/cron.{allow,deny}\n\nat和crontab\n一次性作业使用 at\n重复性作业使用crontab\nCreate at time crontab -e\nList at -l crontab -l\nDetails at -c jobnum crontab -l\nRemove at -d jobnum crontab -r\nEdit N/A crontab -e\n没有被重定向的输出会被邮寄给用户\nroot能够修改其它用户的作业\n\n","tags":["L·H"]},{"title":"三次握手及子网划分","url":"%2F2018%2F10%2F16%2F%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%8F%8A%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86%2F","content":"\n# 三次握手及四次挥手\n\n\n\n**三次握手** （最好能画出图） （一般抓包软件wireshark默认客户端和服务器第一次建立连接，x,y取绝对，为0）\n1. 客户端发送SYN=1,seq=x 到服务器（LISTEN状态）\n2. 服务器收到后 回发SYN=1,ACK=1,seq,=y,ack=x+1 给客户端，说明收到（同步收到状态）\n3. 客户端（同步已发送状态）收到反馈后， 发送ACK=1,seq=x+1,ack=y+1 给服务器，双方建立连接（都为ESTAB-LISHED状态）\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2018110416125017.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MTE1Mg==,size_16,color_FFFFFF,t_70)\n**四次挥手** (最好能画出图)\n1. 客户端(FIN-WAIT-1终止等待1)发送FIN=1,seq=u\n2. 服务器收到后回复 ACK=1,seq=v,ack=u+1给客户端（FIN-WAIT-1终止等待2）\n3. 等待一会服务器(CLOSE_WAIT关闭等待)发送FIN=1,ack=1,seq=w,ack=u+1给客户端（TIME-WAIT时间等待）\n4. 客户端收到后回复ACK=1,seq=u+1,ack=w+1给服务器（LAST-ACK最后确认）\n最后客户端和服务器断开连接\n注：抓包软件wireshark中数据最后几行为分开信息\n分别为: \n[FIN,ACK]\n[ACK]\n[FIN,ACK]\n[ACK]\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20181104161213565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MTE1Mg==,size_16,color_FFFFFF,t_70)\nss -nt |sed -rn '1!s/^([^ ]+).*/\\1/p' |sort  抓取网络连接中有多少状态\n\n\n\n\n\n# 服务器和各个协议端口号：\n>FTP:21\nssh：22\nTelnet:20\nHTTP tcp:80\nHTTPS tcp：443 和HTTP不是一种协议\nDNS:53\nTFTP:69\nSNMPP:161\nQQ :udp 8000 \ndhcp 67,68 snmp 161 \nmysql tcp   3306\noracle tcp  1521 \nsql server  1433 \nkerberos    88/tcp  \nsmtp   25\npop3   110\nimap   143 \nsmb    445\n\n10.00000 000.0.0  10.0.0.0/16\n10.00001 000.0.0  10.8.0.0/16\n10.00011 000.0.0  10.24.0.0/16\n10.00111 000.0.0  10.\n\n10.152.0000 0000 10.152.0.0\n10.152.0000 0000\n\n\n# arp协议\nIP 逻辑地址，可以查询此IP在网络的哪个位置\nMAC地址 物理地址\n1-126.x.y.z  A类地址，全球共126个A类网段\n\n以太网  数据链路层\n以太网帧的数据报文  （和IP的不一样）\n长度 72-1526 去掉前导信息（8）和FCS（4），有用的数据长度为60-1514\nMAC地址唯一，前三位标识各个厂商后三位厂商自定义，\n如34-E1-2D-D0-72-DA，共6个字节，一个字母或数字4位\ntcpdump -i eth0 -nn -X   抓包工具练习\n两主机连接前互相询问MAC地址\narp -n查看获取的MAC地址\n\n协议类型查询：cat /etc/protocols\nTCP 6\nUDP 17\n\n# IP地址类型\n分类\n\n**A类地址**\n1-126.X.Y.Z\n1600万\n网络ID位为高8位，主机ID位为24\n0xxxxxxx.X.Y.Z\n00000000 0\n01111111 127\n\n10.0.0.100\n10.0.0.0  \n10.255.255.255\n\n114.114.114.114\n\n**B类地址**\n128-191.x.y.z\n网络ID位为高16位，主机ID位为16\n10xxxxxx.X.Y.Z\n10000000. 128\n10111111. 191\n65534\n\n172.18.0.100\n\n**C类地址**\n192-223.x.y.z\n网络ID位为高24位，主机ID位为8\n110xxxxx.x.y.z\n11000000 192\n11011111 223\n254\n\n\n**D类地址**\n224-239.x.y.z\n多播地址\n1110xxxx.x.y.z\n\n**E类地址**\n11110xxx.\n240-254.x.y.z\n\n\n\n**************************\n**无类域间路由CIDR:网络id位数不确定,22\nnetmask子网掩码:32bit 二进制,对应于网络ID位为1，对应于主机ID位为0** \n*********************\n\n\n# 子网划分\n\n10.0.0.100/19    255.255.224.0 \n\n203.110.200.199/22                    22为网络ID数，主机ID数=32-网络ID数  \n1 主机数?1022\n2 netmask?255.255.252.0\n3 网络ID值?\n\n203.110.200.199\n\n203.110.110010 00.199\n255.255.111111 00.00000000 \n203.110.110010 00.0/22\n203.110.200.0/22\n\n192.168.34.6\n255.255.255.0\n192.168.34.0/24\n\n\n0与1=0\n0与0=0\n1与0=0\n1与1=1\n\nA 192.168.1.100 \n  255.255.255.0\n \n\nB 192.168.2.100 \n  255.255.0.0\n \n\n**A ：172.18.0.100 255.0.0.0  172.18.0.0/16\nB： 172.18.0.123 255.255.255.0 172.18.0.0/24**\n\n例子：\n```bash\n100.123.199.124/20\n1 主机数  2^12-2\n2 子网掩码 255.255.240.0 \n3 网络ID:100.123.192.0/20\n4 最小和最大IP:100.123.192.1 --- 100.123.207.254\n\n100.123.11000111.124\n255.255.240.0 \n100.123.1100 0000.1 \n100.123.1100 1111.254 \n\n123.200.233.100/23  \n123.200.235.100/23  \n\n\n\n\n100.123.1100  0000.000000001\n100.123.1100  1111.111111110\n\n00000000  0\n10000000  128\n11000000  192\n11100000  224\n11110000  240\n11111000  248\n11111100  252\n11111110  254\n11111111  255\n\n00000001  1\n00000010  2\n00000100  4\n00001000  8\n00010000  16\n00100000  32\n01000000  64\n10000000  128\n\n10.0.0.1--10.255.255.254  \n10.00 000000.0.0\n\n10.00 000000.0.0   10.0.0.0/10\n10.01 000000.0.0   10.64.0.0/10\n10.10 000000.0.0   10.128.0.0/10\n10.11 000000.0.0   10.192.0.0/10\n\n10.0 0000000.0.0   10.0.0.0/9 \n10.1 0000000.0.0   10.128.0.0/9\n\n10.0.0.0/8 给32省份划分各自子网\n借5位\n1 子网子网掩码 255.248.0.0 \n2 最小子网，最大子网的网络ID\n10.00000  000.0.0  10.0.0.0/13\n10.11111  000.0.0  10.248.0.0/13\n3 每个子网主机数？2^19-2\n4 第20个子网分给河南使用，最小IP10.152.0.1，最大IP范围10.159.255.254\n\n10.10011  000.0.1       \n10.10011  111.255.254   \n```\n\n\n\n**子网掩码和网关在一个网段才能上网，/后的数字为网络id位数，从前往后查多少位不变的**\n公式：\n1. 一个网络中主机最大数=2^主机ID位数(32-网络ID位数)^-2=2^(32-网络ID位数)^-2\n2. 网络数=2^可变网络ID位\n3. CIDR表示法：IP/网络ID位数\n4. 网络ID值=IP与子网掩码\n5. 划分子网：一个大网划分成多个小网，网络ID位变多，主机ID位才变少，网络ID向主机ID借位N,分成2^N个小网\n6. 合并超网：多个小网合并成一个大网，主机ID向网络ID借位\n\n例子 ：\n\n河南省10.152.0.0/13 给15个地市，划分各自子网 2^N^>=15 N=4\n1 子网子网掩码 \n 17 255.255.128.0\n\n2 最小子网，最大子网的网络ID\n\n10.10011  000.0  0000000.0 10.152.0.0/17\n10.10011  111.1  0000000.0 10.159.128.0/17\n\n3 每个子网主机数？ 2^(32-17)^-2 \n\n4 最大子网的最小IP，最大IP范围 10.159.128.1——10.159.255.254\n\n10.10011  111.1  0000000.0\n10.10011  111.1  0000000.1  10.159.128.1\n10.10011  111.1  1111111.254 10.159.255.254\n\n 河南省10.152.0.0/13 给87个区县，划分各自子网 \n1 子网子网掩码   \n 21 255.255.248.0\n\n2 最小子网，最大子网的网络ID\n\n10.10011  000.00000  000.0  10.152.0.0/21\n10.10011  111.11111  000.0  10.159.248.0/21\n\n3 每个子网主机数？   2^11-2\n\n4 最大子网 的最小IP，最大IP范围 \n\n10.10011  111.11111  000.0    10.159.248.1\n10.10011  111.11111  111.254  10.159.255.254\n******************************************************\n\n路由表：\n目标网络ID：目标IP所在网络ID  \n接口：本设备要发送数据包到目标，从哪个接口发送出来，才能到达\n网关：到达目标网络，需要将数据交给下一个路口哪个接口的对应的IP\n\n","tags":["L·H"]},{"title":"磁盘备份及raid0和raid10的组建","url":"%2F2018%2F10%2F15%2F%E7%A3%81%E7%9B%98%E5%A4%87%E4%BB%BD%E5%8F%8Araid0%E5%92%8Craid10%E7%9A%84%E7%BB%84%E5%BB%BA%2F","content":"\n# blkid 查询各个设备UUID\n```bash\nmount -U 'UUID' 加挂载点  挂载设备\numount /mnt/sdb1  卸载挂载设备sdb1（无占用）  \nlsof /mnt/sdb1   有用户占用时，查询sdb1占用进程和用户\nfuser -km /mnt/sdb1  结束sdb1的所有占用\ncat /proc/mounts 查询所有的挂载点\numount -o remount +挂载点 重新挂载，某些设备不能取消挂载\n\ndf -P  对其系统信息显示\ndu    显示当前目录每个文件夹的大小\ndu -sh  显示当前目录的总大小\ndu -sh /*查询根目录下每个目录有多大\n\ndd 命令**********************\ndd if= /dev读取的文件    of=/输出的文件，没有则新建该文件\n```\n例子 \n```bash\nf1=abcdefghi\nf2= 123456\ndd if=f2 of=f1 bs=1 count=2 skip=3 seek=4 一次1块，跳过源文件的3个（123），读取两个（45），f1跳过4个，把ef替代了\n输出信息为abcd45 \n\n备份：\ndd if=/dev/sdx of=/dev/sdy\n将本地的/dev/sdx整盘备份到/dev/sdy\ndd if=/dev/sdx of=/path/to/image\n将/dev/sdx全盘数据备份到指定路径的image文件\ndd if=/dev/sdx | gzip >/path/to/image.gz\n备份/dev/sdx全盘数据，并利用gzip压缩，保存到指定路径\n恢复：\ndd if=/path/to/image of=/dev/sdx\n将备份文件恢复到指定盘\ngzip -dc /path/to/image.gz | dd of=/dev/sdx\n将压缩的备份文件恢复到指定盘\n```\n\n# 拷贝内存资料到硬盘\n```bash\ndd if=/dev/mem of=/root/mem.bin bs=1024\n将内存里的数据拷贝到root目录下的mem.bin文件\n从光盘拷贝iso镜像\ndd if=/dev/cdrom of=/root/cd.iso\n拷贝光盘数据到root文件夹下，并保存为cd.iso文件\n销毁磁盘数据\ndd if=/dev/urandom of=/dev/sda1\n利用随机的数据填充硬盘，在某些必要的场合可以用来销毁数据，执行此操作以后，\n/dev/sda1将无法挂载，创建和拷贝操作无法执行\n```\n# 测试硬盘写速度\n```bash\ndd if=/dev/zero of=/root/1Gb.file bs=1024 count=1000000\n测试硬盘读速度\ndd if=/root/1Gb.file bs=64k | dd of=/dev/null\npartx -d --nr 1 /dev/sdb  删除硬盘sdb上的第一个分区\n删除硬盘上的一个分区\n```\n\nraid 01 容错率3分之1\nraid 10 容错率3分之2\n所以一般都用raid 10 或者20.30 \n\n简述 raid0，raid1，raid5，raid10 的区别和各自特点：\n\n>raid0:RAID0 具有低成本、高读写性能、 100% 的高存储空间利用率等优点，但是它不提供数据冗余保护，一\n旦数据损坏，将无法恢复。 因此， RAID0 一般适用于对性能要求严格但对数据安全性和可靠性不高的\n应用。\nraid1:RAID1 称为镜像，它将数据完全一致地分别写到工作磁盘和镜像磁盘，从而达到安全性好、技术简单、\n管理方便。 RAID1 拥有完全容错的能力，但实现成本高。\nraid5:RAID5 的磁盘上同时存储数据和校验数据，数据块和对应的校验信息存保存在不同的磁盘上，当一个数\n据盘损坏时，系统可以根据同一条带的其他数据块和对应的校验数据来重建损坏的数据。与其他 RAID\n等级一样，重建数据时， RAID5 的性能会受到较大的影响。RAID5 兼顾存储性能、数据安全和存储成\n本等各方面因素，它可以理解为 RAID0 和 RAID1 的折中方案，是目前综合性能最佳的数据保护解决方\n案。\nraid10：RAID10 是先做镜像再作条带化，是对虚拟磁盘实现镜像，保证数据安全性的同时又提高了性能，整\n体磁盘利用率均仅为 50%。\n\n\n\nraid5在视频第12天第三个视频64分钟开始\n# 实验：实现raid0\nVMware中添加两块200G硬盘，重启虚拟机\n输入lsblk查看多了一个sdb 硬盘\nfdisk /dev/sdb\n```bash\nDevice contains neither a valid DOS partition table, nor Sun, SGI or OSF disklabel\nBuilding a new DOS disklabel with disk identifier 0x25e5fb5c.\nChanges will remain in memory only, until you decide to write them.\nAfter that, of course, the previous content won't be recoverable.\n\nWarning: invalid flag 0x0000 of partition table 4 will be corrected by w(rite)\n\nWARNING: DOS-compatible mode is deprecated. It's strongly recommended to\n         switch off the mode (command 'c') and change display units to\n         sectors (command 'u').\n\nCommand (m for help): n\nCommand action\n   e   extended\n   p   primary partition (1-4)\n1\nInvalid partition number for type `1'\nCommand action\n   e   extended\n   p   primary partition (1-4)\np\nPartition number (1-4): 1\nFirst cylinder (1-26108, default 1): \nUsing default value 1\nLast cylinder, +cylinders or +size{K,M,G} (1-26108, default 26108): +50G\n\nCommand (m for help): t\nSelected partition 1\nHex code (type L to list codes): fd\nChanged system type of partition 1 to fd (Linux raid autodetect)\n\nCommand (m for help): p\n\nDisk /dev/sdc: 214.7 GB, 214748364800 bytes\n255 heads, 63 sectors/track, 26108 cylinders\nUnits = cylinders of 16065 * 512 = 8225280 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\nDisk identifier: 0x25e5fb5c\n\n   Device Boot      Start         End      Blocks   Id  System\n/dev/sdc1               1        6528    52436128+  fd  Linux raid autodetect\n\nCommand (m for help): w\nThe partition table has been altered!\n\nCalling ioctl() to re-read partition table.\nSyncing disks.\n然后按w保存分区信息**************************\n```\n分区完成 \n若lsblk后没有新建的分区，可以输入partx -a /dev/sdb  来通知内核重新读取分区表  \n或者输入partprobe 进行分区同步\n**************************************************************************************************\n重复以上步骤将sdc也创建一个50G的分区\n```bash\nlsblk\nNAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT\nsda      8:0    0  200G  0 disk \n├─sda1   8:1    0    1G  0 part /boot\n├─sda2   8:2    0 48.8G  0 part /\n├─sda3   8:3    0 29.3G  0 part /data\n├─sda4   8:4    0    1K  0 part \n└─sda5   8:5    0    2G  0 part [SWAP]\nsdb      8:16   0  200G  0 disk \n└─sdb1   8:17   0   50G  0 part \nsdc      8:32   0  200G  0 disk \n└─sdc1   8:33   0   50G  0 part \nsr0     11:0    1  3.7G  0 rom \n可以看到sdb1和sdc1两个50G的分区\n将两个分区组成raid0\nmdadm -C -a yes /dev/md0 -l 0 -n 2 /dev/sd{b,c}1\nlsblk\nNAME    MAJ:MIN RM  SIZE RO TYPE  MOUNTPOINT\nsda       8:0    0  200G  0 disk  \n├─sda1    8:1    0    1G  0 part  /boot\n├─sda2    8:2    0 48.8G  0 part  /\n├─sda3    8:3    0 29.3G  0 part  /data\n├─sda4    8:4    0    1K  0 part  \n└─sda5    8:5    0    2G  0 part  [SWAP]\nsdb       8:16   0  200G  0 disk  \n└─sdb1    8:17   0   10G  0 part  \n  └─md0   9:0    0   20G  0 raid0 /mnt/raid\nsdc       8:32   0  200G  0 disk  \n└─sdc1    8:33   0   10G  0 part  \n  └─md0   9:0    0   20G  0 raid0 /mnt/raid\nsr0      11:0    1  3.7G  0 rom \nmkfs.ext4 /dev/md0    给raid0创建文件系统\nblkid\nmkdir /mnt/raid     创建挂载点\ntune2fs -L /mnt/raid /dev/md0   挂载md0  \n输入partprobe 进行分区同步\ndf -h 可以看到raid0组建完成\n```\n*******************************************************************\n# 测试组建raid前后速度\n```bash\ndd if=/dev/zero of=/mnt/raid/f1 bs=1M count=1024   raid0速度\n1024+0 records in\n1024+0 records out\n1073741824 bytes (1.1 GB) copied, 4.94718 s, 217 MB/s\ndd if=/dev/zero of=/data/f2 bs=1M count=1024    普通硬盘速度\n1024+0 records in\n1024+0 records out\n1073741824 bytes (1.1 GB) copied, 23.4932 s, 45.7 MB/s\n********************************************************************8\nraid0和raid1组建区别\nmdadm -C -a yes /dev/md0 -l 0 -n 2 /dev/sd{b,c}1   raid0\nmdadm -C -a yes /dev/md0 -l 1 -n 2 /dev/sd{b,c}1   raid1\n\n将-l 后的类别改为1就是raid1\n```\n# RAID10组建\n组建raid10就是先组建两个raid0，组合成raid1\n再次添加两个硬盘sdd,sde重启系统，或者刷新硬件信息\n```bash\nmdadm -C -a yes /dev/md0 -l 0 -n 2 /dev/sd{d,e}1\numount /dev/md0   取消挂载md0\nmdadm -C -a yes /dev/md2 -l 1 -n 2 /dev/md{0,1}   将两个raid0组建为raid10\nlsblk  查看是否有md2\ndf -h看到没有md2\nmkfs.ext4 /dev/md2  创建文件系统\nmkdir /mnt/raid111  创建挂载点\nmount /dev/md2 /mnt/raid111  挂载raid10\nvim /etc/fstab  写入raid10 信息,重启后raid10不会丢失\npartprobe 同布信息\ndf -h 可以看到有了md2\n\nmdadm -D /dev/md0    删除raid0\n```","tags":["L·H"]},{"title":"Linux进程管理","url":"%2F2018%2F10%2F15%2FLinux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%2F","content":"\nps常见选项\nps\n```bash\nC cmdlist 指定命令，多个命令用，分隔\nL 显示线程\ne: 显示所有进程，相当于-A\nf: 显示完整格式程序信息\nF: 显示更完整格式的进程信息\nH: 以进程层级格式显示进程相关信息\nu userlist 指定有效的用户ID或名称\nU userlist 指定真正的用户ID或名称\ng gid或groupname 指定有效的gid或组名称\nG gid或groupname 指定真正的gid或组名称\np pid 显示指pid的进程\n-ppid pid 显示属于pid的子进程\nM 显示SELinux信息，相当于Z\n```\nps输出属性\n```bash\nVSZ: Virtual memory SiZe，虚拟内存集，线性内存\nRSS: ReSident Size, 常驻内存集\nSTAT：进程状态\nR：running\nS: interruptable sleeping\nD: uninterruptable sleeping\nT: stopped\nZ: zombie\n+: 前台进程\nl: 多线程进程\nL：内存分页并带锁\nN：低优先级进程\n<: 高优先级进程\ns: session leader，会话（子进程）发起者\n```\nps示例\n\n>询你拥有的所有进程\nps -x\n示指定用户名(RUID)或用户ID的进程\nps -fU apache\nps -fU 48\n示指定用户名(EUID)或用户ID的进程\nps -fu wang\nps -fu 1000\n看以root用户权限（实际和有效ID）运行的每个进程\nps -U root -u root\n出某个组拥有的所有进程（实际组ID：RGID或名称）\nps -fG nginx\n列出有效组名称（或会话）所拥有的所有进程\nps -fg mysql\nps -fg 27\n示指定的进程ID对应的进程\nps -fp 1234\n父进程ID来显示其下所有的进程，如显示父进程为1234的所有进程\nps -f --ppid 1234\n示指定PID的多个进程\nps -fp 1204,1239,1263\n按tty显示所属进程\nps -ft pts/0\n自定义格式显示文件系统组,ni值开始时间和进程的时间\nps -p 1234 -o pid,ppid,fgroup,ni,lstart,etime\n用其PID查找进程名称：\nps -p 1244 -o comm=\n以其名称选择特定进程，显示其所有子进程\nps -C sshd,bash\n找指定进程名所有的所属PID，在编写需要从std输出或文件读取PID的脚本时\n这个参数很有用\nps -C httpd,sshd -o pid=\n查一个进程的执行时间\nps -eo comm,etime,user | grep nginx\n\n# 搜索进程\n灵活：ps 选项 | 其它命令\n预定义的模式：pgrep\n```bash\npgrep [options] pattern\n-u uid: effective user，生效者\n-U uid: real user，真正发起运行命令者\n-t terminal: 与指定终端相关的进程\n-l: 显示进程名\n-a: 显示完整格式的进程名\n-P pid: 显示指定进程的子进程\n确切的程序名称：/sbin/pidof\npidof bash\n```\n## 进程管理工具top\ntop：有许多内置命令\n排序：\nP：以占据的CPU百分比,%CPU\nM：占据内存百分比,%MEM\nT：累积占据CPU时长,TIME+\n首部信息显示：\nuptime信息：l命令\ntasks及cpu信息：t命令\ncpu分别显示：1 (数字)\nmemory信息：m命令\n退出命令：q\n修改刷新时间间隔：s\n终止指定进程：k\n保存文件：W\ntop选项：\n-d # 指定刷新时间间隔，默认为3秒\n-b 全部显示所有进程\n-n # 刷新多少次后退出\n-H 线程模式，示例：top -H -p pidof mysqld\n\n## htop命令：EPEL源\n选项：\n-d #: 指定延迟时间；\n-u UserName: 仅显示指定用户的进程\n-s COLUME: 以指定字段进行排序\n子命令：\ns：跟踪选定进程的系统调用\nl：显示选定进程打开的文件列表\na：将选定的进程绑定至某指定CPU核心\nt：显示进程树\n\n内存空间\n存空间使用状态：\n\nfree [OPTION]\n-b 以字节为单位\n-m 以MB为单位\n-g 以GB为单位\n-h 易读格式\n-o 不显示-/+buffers/cache行\n-t 显示RAM + swap的总和\n-s n 刷新间隔为n秒\n-c n 刷新n次后即退出\n\n## 内存工具\nvmstat命令：虚拟内存信息\nvmstat [options] [delay [count]]\nvmstat 2 5\nprocs:\nr：可运行（正运行或等待运行）进程的个数，和核心数有关\nb：处于不可中断睡眠态的进程个数(被阻塞的队列的长度)\nmemory：\n\nswpd: 交换内存的使用总量\nfree：空闲物理内存总量\nbuffer：用于buffer的内存总量\ncache：用于cache的内存总量\nswap:\nsi：从磁盘交换进内存的数据速率(kb/s)\nso：从内存交换至磁盘的数据速率(kb/s)\n\n## 系统监控工具\n```bash\nglances命令：EPEL源\nglances [-bdehmnrsvyz1] [-B bind] [-c server] [-C conffile] [-p port] [-P password] [–\npassword] [-t refresh] [-f file] [-o output]\n内建命令：\na Sort processes automatically l Show/hide logs\nc Sort processes by CPU% b Bytes or bits for network I/O\nm Sort processes by MEM% w Delete warning logs\np Sort processes by name x Delete warning and critical logs\ni Sort processes by I/O rate 1 Global CPU or per-CPU stats\nd Show/hide disk I/O stats h Show/hide this help screen\nf Show/hide file system stats t View network I/O as combination\nn Show/hide network stats u View cumulative network I/O\ns Show/hide sensors stats q Quit (Esc and Ctrl-C also work)\ny Show/hide hddtemp stats\n常用选项：\n-b: 以Byte为单位显示网卡数据速率\n-d: 关闭磁盘I/O模块\n-f /path/to/somefile: 设定输入文件位置\n-o {HTML|CSV}：输出格式\n-m: 禁用mount模块\n-n: 禁用网络模块\n-t #: 延迟时间间隔\n-1：每个CPU的相关数据单独显示\n```\n例子：\nglances 远程监控\n远程监控另一台虚拟机\n需要两台虚拟机同为centos6或者centos7版本，否则不兼容\n虚拟机A作为服务器\n```bash\nyum install glances  #安装glances 工具\nglances -s  #开启服务\n虚拟机B作为客户端\n\nyum install glances  #安装glances 工具\nglances -c 192.168.34.129  #输入服务器IP地址\n\n在虚拟机B上可以看到以下信息\n\nConnected to centos7.localdomain (CentOS Linux 7.5.1804 64bit / Linux 3.10.0-862.el7.x86_64)      Uptime: 0:07:49\n\nCPU  [  4.4%]   CPU       4.4%  nice:     0.0%        MEM     41.7%        SWAP      0.0%        LOAD    1-core\nMEM  [ 41.7%]   user:     1.3%  irq:      0.0%        total:  1.78G        total:   4.00G        1 min:    0.01\nSWAP [  0.0%]   system:   2.5%  iowait:   0.0%        used:    760M        used:        0        5 min:    0.15\n                idle:    96.2%  steal:    0.0%        free:   1.04G        free:    4.00G        15 min:   0.12\n\nNETWORK     Rx/s   Tx/s   TASKS 200 (467 thr), 2 run, 198 slp, 0 oth sorted automatically\nens33        3Kb   62Kb\nens37        1Kb   648b     CPU%  MEM%  VIRT   RES   PID USER        NI S     TIME+ IOR/s IOW/s Command \nlo            0b     0b      9.8   0.8  221M 15.1M  2858 root         0 R   0:00.33     0     0 /usr/bin/python /\nvirbr0        0b     0b      0.0   0.5  548M 9.50M  2430 luhao       19 S   0:00.40     0     0 /usr/libexec/trac\n_rbr0-nic     0b     0b      0.0   0.3  105M 5.34M   686 root         0 S   0:00.20     0     0 /sbin/dhclient -d\n                             0.0   3.2 1.15G 57.9M  2488 luhao        0 S   0:00.24     0     0 /usr/libexec/evol\nDISK I/O     R/s    W/s      0.0   0.0     0     0   438 root       -20 S   0:00.00     0     0 xfs-buf/sda1\nsda1           0      0      0.0   0.0 60.7M  400K   598 avahi        0 S   0:00.00     0     0 avahi-daemon: chr\nsda2           0      0      0.0   0.0     0     0   448 root       -20 S   0:00.00     0     0 xfs-conv/sda3\nsda3           0      0      0.0   0.3  367M 5.46M  2117 luhao        0 S   0:00.00     0     0 /usr/libexec/ibus\nsda4           0      0      0.0   0.3  410M 6.06M  1752 colord       0 S   0:00.30     0     0 /usr/libexec/colo\nsda5           0      0      0.0   0.4  603M 7.12M  2309 luhao        0 S   0:00.20     0     0 /usr/libexec/gsd-\nsr0            0      0      0.0   0.2  363M 3.05M  2168 luhao        0 S   0:00.00     0     0 /usr/libexec/gvfs\n                             0.0   0.3  550M 5.48M  2156 luhao        0 S   0:00.20     0     0 /usr/libexec/gvfs\nFILE SYS    Used  Total      0.0   0.0     0     0     5 root       -20 S   0:00.00     0     0 kworker/0:0H\n/ (sda2)   3.86G  50.0G      0.0   0.0     0     0    10 root       -20 S   0:00.00     0     0 lru-add-drain\n/boot       165M  1014M      0.0   0.7  677M 13.6M   953 root         0 S   0:00.37     0     0 /usr/sbin/libvirt\n/data      32.2M  30.0G      0.0   0.2  193M 4.09M   944 root         0 S   0:00.10     0     0 /usr/sbin/cupsd -\n_7 x86_64  8.75G  8.75G      0.0   0.0 52.6M  372K  1401 root         0 S   0:00.00     0     0 /usr/sbin/dnsmasq\n                             0.0   0.0     0     0    29 root        19 S   0:00.36     0     0 khugepaged\n                             0.0   0.8  708M 13.9M  2254 luhao        0 S   0:00.11     0     0 /usr/libexec/gsd-\n                             0.0   0.0     0     0    41 root       -20 S   0:00.00     0     0 kaluad\n                             0.0   0.0     0     0   531 root       -20 S   0:00.00     0     0 rpciod\n                             0.0   0.0     0     0   532 root       -20 S   0:00.00     0     0 xprtiod\n                             0.0   0.4 1.23G 6.91M  2097 luhao      -11 S   0:00.12     0     0 /usr/bin/pulseaud\n                             0.0   0.0     0     0   225 root       -20 S   0:00.00     0     0 ata_sff\n                             0.0   0.1 23.9M 2.21M   555 root         0 S   0:00.20     0     0 /usr/sbin/smartd\n                             0.0   0.2  454M 4.44M  2381 luhao        0 S   0:00.30     0     0 /usr/libexec/gvfs\n                             0.0   0.5  625M 10.0M  2416 luhao       19 S   0:00.50     0     0 /usr/libexec/trac\n                             0.0   0.4  597M 6.50M  2284 luhao        0 S   0:00.20     0     0 /usr/libexec/gsd-\n                             0.0   0.0     0     0   444 root       -20 S   0:00.00     0     0 xfs-conv/sda1\n                             0.0   0.3  367M 5.25M  2124 luhao        0 S   0:00.10     0     0 /usr/libexec/ibus\n```\n系统监控工具\ndstat命令：系统资源统计,代替vmstat,iostat\n```bash\ndstat [-afv] [options..] [delay [count]]\n-c 显示cpu相关信息\n-C #,#,...,total\n-d 显示disk相关信息\n-D total,sda,sdb,...\n-g 显示page相关统计数据\n-m 显示memory相关统计数据\n-n 显示network相关统计数据\n-p 显示process相关统计数据\n-r 显示io请求相关的统计数据\n-s 显示swapped相关的统计数据\n```\n## iotop常用参数\no, --only只显示正在产生I/O的进程或线程，除了传参，可以在运行过程中按o\n生效\nb, --batch非交互模式，一般用来记录日志\nn NUM, --iter=NUM设置监测的次数，默认无限。在非交互模式下很有用\nd SEC, --delay=SEC设置每次监测的间隔，默认1秒，接受非整形数据例如1.1\np PID, --pid=PID指定监测的进程/线程\nu USER, --user=USER指定监测某个用户产生的I/O\nP, --processes仅显示进程，默认iotop显示所有线程\na, --accumulated显示累积的I/O，而不是带宽\nk, --kilobytes使用kB单位，而不是对人友好的单位。在非交互模式下，脚本\n编程有用\n-t, --time 加上时间戳，非交互非模式\nq, --quiet 禁止头几行，非交互模式，有三种指定方式\n-q 只在第一次监测时显示列名\n-qq 永远不显示列名\n-qqq 永远不显示I/O汇总\n交互按键\nleft和right方向键：改变排序\nr：反向排序\no：切换至选项–only\np：切换至–processes选项\na：切换至–accumulated选项\nq：退出\ni：改变线程的优先级\n\nlsof\nlsof：list open files查看当前系统文件的工具。在linux环境下，一切皆文件，\n用户通过文件不仅可以访问常规数据，还可以访问网络连接和硬件如传输控制\n协议 (TCP) 和用户数据报协议 (UDP)套接字等，系统在后台都为该应用程序分\n配了一个文件描述符\n命令参数\n```bash\nlsof\n-a：列出打开文件存在的进程\n-c<进程名>：列出指定进程所打开的文件\n-g：列出GID号进程详情\n-d<文件号>：列出占用该文件号的进程\n+d<目录>：列出目录下被打开的文件\n+D<目录>：递归列出目录下被打开的文件\n-n<目录>：列出使用NFS的文件\n-i<条件>：列出符合条件的进程(4、6、协议、:端口、 @ip )\n-p<进程号>：列出指定进程号所打开的文件\n-u：列出UID号进程详情\n-h：显示帮助信息\n-v：显示版本信息。\n-n: 不反向解析网络名字\nlsof /dev/pts/0   #查看由系统启动的进程  0改为1是看用户的进程\n指定进程号，可以查看该进程打开的文件\nlsof -p 9527\n文件管理\n查看指定程序打开的文件\nlsof -c httpd\n查看指定用户打开的文件\nlsof -u root | more\n查看指定目录下被打开的文件\nlsof +D /var/log/\nlsof +d /var/log/\n参数+D为递归列出目录下被打开的文件，参数+d为列出目录下被打开的文件\n```\n\n例子：\n```bash\n[root@centos6 ~]#lsof /dev/pts/0\nCOMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME\nbash    27075 root    0u   CHR  136,0      0t0    3 /dev/pts/0\nbash    27075 root    1u   CHR  136,0      0t0    3 /dev/pts/0\nbash    27075 root    2u   CHR  136,0      0t0    3 /dev/pts/0\nbash    27075 root  255u   CHR  136,0      0t0    3 /dev/pts/0\nlsof    37913 root    0u   CHR  136,0      0t0    3 /dev/pts/0\nlsof    37913 root    1u   CHR  136,0      0t0    3 /dev/pts/0\nlsof    37913 root    2u   CHR  136,0      0t0    3 /dev/pts/0\n\nlsof -i :22 #查询22端口被哪个进程占用\n例子：\n\nlsof -i :22\nCOMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME\nsshd     1932 root    3u  IPv4  12343      0t0  TCP *:ssh (LISTEN)\nsshd     1932 root    4u  IPv6  12345      0t0  TCP *:ssh (LISTEN)\nsshd    27073 root    3r  IPv4  39440      0t0  TCP 192.168.34.128:ssh->192.168.34.1:54867 (ESTABLISHED)\n```\n进程管理工具kill\nkill命令：向进程发送控制信号，以实现对进程管理,每个信号对应一个数字，信号名称以SIG开头（可省略），不区分大小写\n显示当前系统可用信号： kill –l 或者 trap -l\n常用信号：man 7 signal\n\n>SIGHUP 无须关闭进程而让其重读配置文件\nSIGINT 中止正在运行的进程；相当于Ctrl+c\nSIGQUIT 相当于ctrl+\\\nSIGKILL 强制杀死正在运行的进程\nSIGTERM 终止正在运行的进程\nSIGCONT 继续运行\nSIGSTOP 后台休眠\n指定信号的方法 : (1) 信号的数字标识：1, 2, 9\n(2) 信号完整名称：SIGHUP\n(3) 信号的简写名称：HUP\npidof bc 查看计算器的进程号\nkill ‘pidof bc’ 停止进程\n按PID：\n\nkill [-SIGNAL] pid …\nkill –n SIGNAL pid\nkill –s SIGNAL pid\n按名称：killall [-SIGNAL] comm…\n按模式：pkill [options] pattern\n>-SIGNAL\n-u uid: effective user，生效者\n-U uid: real user，真正发起运行命令者\n-t terminal: 与指定终端相关的进程\n-l: 显示进程名（pgrep可用）\n-a: 显示完整格式的进程名（pgrep可用）\n-P pid: 显示指定进程的子进程\n\n并行执行\n同时运行多个进程，提高效率\n方法1\nvi all.sh\n```bash\nf1.sh&\nf2.sh&\nf3.sh&\n方法2\n(f1.sh&);(f2.sh&);(f3.sh&)\n方法3\n{ f1.sh& f2.sh& f3.sh& }\n```\n例子： 同时ping四个地址\n```bash\n{\nping -c2 127.0.0.1\nping 127.0.0.2\n}&\n\n{\nping -c2 127.0.0.3\nping 127.0.0.4\n}&\n```\n例子：\n并行ping172.18.133网段的254个IP，并输出结果\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20181108195422192.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MTE1Mg==,size_16,color_FFFFFF,t_70)\n\n\n","tags":["L·H"]},{"title":"逻辑卷LVM的管理","url":"%2F2018%2F10%2F11%2F%E9%80%BB%E8%BE%91%E5%8D%B7LVM%E7%9A%84%E7%AE%A1%E7%90%86%2F","content":"\n# 1实验：扩展VG\n```bash\npvcreate /dev/sdc  将新加的硬盘创建为物理卷\npvs 查询物理卷\nvgextend vg0 /dev/sdc  扩展vg0，将sdc加进去\nlvextend 通用扩展命令，6，7都可以用\n```\n# 2实验：缩减 *********LVM\n```bash\n\n1 umount /mnt/mysql        卸载逻辑卷\n\n2 fsck -f /dev/vg0/lv_mysql  检查系统的完整性\n\n3 resize2fs /dev/vg0/lv_mysql 20G  缩减到20G\n\n4 lvreduce -L 20 /dev/vg0/lv_mysql  缩减逻辑卷到20G\n\n5 mount /dev/vg0/lv_mysql /mnt/mysql  挂载逻辑卷\n```\n\n# 实验：扩展*********LVM \n```bash\n\n1 vgdisplay 查看VG有空闲空间\n\n2 lvextend -l +100%FREE /dev/vg0/lv_mysql\n\n3 resize2fs /dev/vg0/lv_mysql\n\n2，3合并成lvextend\nlvextend -r -L  5G /dev/vg0/lv_data  \n\n4 df \n```\n\n# 实验：创建LVM\n```bash\nfdisk t 8e /dev/sda6  /dev/sdc  创建分区并t修改格式为8e\n \npvcreate /dev/sda6  /dev/sdc   创建物理卷\n\nvgcreate vg0 /dev/sda6  /dev/sdc   添加两个物理卷到卷组vg0\n\nlvcreate -n lv_mysql -L 15G vg0     从卷组中分出15G创建逻辑卷\n\nmkfs.ext4 /dev/vg0/lv_mysql   创建文件系统\n\nmkdir /mnt/mysql    创建挂载点\n\nmount /dev/vg0/lv_mysql /mnt/mysql   挂载逻辑卷\n```\n\n# 实验：迁移逻辑卷LVM中的PE\n```bash\npvmove /dev/sda6  将逻辑卷中的被占用PE迁移到其他逻辑卷\nvgreduce vg0/dev/sda6  将逻辑卷从卷组vg0中删除\nfdisk /dev/sda6 删除分区sda6\nvgrename vg0 vg1 将卷组改名为vg1\n\n```\n\n# 实验：ext LV的快照,并恢复\n```bash\nlvcreate -n lv_data_snap -p r  -s -L 1G /dev/vg0/lv_data\nmount -o  /dev/vg0/lv_data_snap /mnt/snap/\numount /mnt/data\numount /mnt/snap/\nlvconvert  --merge /dev/vg0/lv_data_snap \n\n```","tags":["L·H"]},{"title":"实验：增加一块新硬盘，分区，创建文件系统XFS|EXT4，并挂载","url":"%2F2018%2F10%2F09%2F%E5%AE%9E%E9%AA%8C%EF%BC%9A%E5%A2%9E%E5%8A%A0%E4%B8%80%E5%9D%97%E6%96%B0%E7%A1%AC%E7%9B%98%EF%BC%8C%E5%88%86%E5%8C%BA%EF%BC%8C%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FXFS%2CEXT4%EF%BC%8C%E5%B9%B6%E6%8C%82%E8%BD%BD%2F","content":"\n# 实验：增加一块新硬盘，分区，创建文件系统XFS|EXT4，并挂载\n*****************************************************************************************\nVMware中添加一块200G硬盘，重启虚拟机\n输入lsblk查看多了一个sdb 硬盘\n```bash\nfdisk /dev/sdb\nCommand (m for help): m\nCommand action\n   a   toggle a bootable flag\n   b   edit bsd disklabel\n   c   toggle the dos compatibility flag\n   d   delete a partition                                  删除一个分区\n   g   create a new empty GPT partition table\n   G   create an IRIX (SGI) partition table\n   l   list known partition types\n   m   print this menu\n   n   add a new partition                                 创建一个分区\n   o   create a new empty DOS partition table\n   p   print the partition table                          查看分区信息\n   q   quit without saving changes\n   s   create a new empty Sun disklabel\n   t   change a partition's system id\n   u   change display/entry units\n   v   verify the partition table\n   w   write table to disk and exit                        保存写入分区操作信息，不按w分区不保存\n   x   extra functionality (experts only)\n按m进入交互式操作\n按n新建一个分区，如下\nCommand (m for help): n\nPartition type:\n   p   primary (0 primary, 0 extended, 4 free)       主分区\n   e   extended                                      扩展分区\nSelect (default p): p\nPartition number (1-4, default 1): 1                  分区编号\nFirst sector (2048-41943039, default 2048): \nUsing default value 2048\nLast sector, +sectors or +size{K,M,G} (2048-41943039, default 41943039): +50G      分区大小            \nPartition 1 of type Linux and of size 1 GiB is set\n\nCommand (m for help): p                                             显示分区信息\n\nDisk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectors\nUnits = sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\nDisk label type: dos\nDisk identifier: 0x1cc76008\n\n   Device Boot      Start         End      Blocks   Id  System\n/dev/sdb1            2048     2099199     1048576   83  Linux\n然后按w保存分区信息**************************\n```\n分区完成 \n若lsblk后没有新建的分区，可以输入partx -a /dev/sdb  来通知内核重新读取分区表  或者输入partprobe 进行分区同步\n","tags":["L·H"]},{"title":"实验：迁移/home目录到新分区中","url":"%2F2018%2F10%2F07%2F%E5%AE%9E%E9%AA%8C%EF%BC%9A%E8%BF%81%E7%A7%BBhome%E7%9B%AE%E5%BD%95%E5%88%B0%E6%96%B0%E5%88%86%E5%8C%BA%E4%B8%AD%2F","content":"\n# 实验：迁移/home目录到新分区中\n```bash\n#先添加一块新的硬盘，重启虚拟机\nlsblk看到新硬盘为sdc\nfdisk /dev/sdc  新建一个分区sdc1\nblkid\nmkfs.xfs /dev/sdc1  创建文件系统\nmkdir /mnt/home  创建新的挂载点\nmount /dev/sdc1 /mnt/home  将光盘进行挂载\ncp -av /home/. /mnt/home 将原来home下的所有文件复制到/mnt/home下\nll mnt/home\ndu -sh /mnt/home\ndu -sh /home   比较两文件夹的大小，看复制是否完整\nvim /etc/fstab 命令模式下写入:r!blkid /dev/sdc1 修改后按wq保存退出\nmount -a 使挂载生效\ndf -h   查看占用\numount /home 取消挂载\nrm -rf /home/* 删除home中的文件\n\n```","tags":["L·H"]},{"title":"磁盘及文件系统分区","url":"%2F2018%2F10%2F06%2F%E7%A3%81%E7%9B%98%E5%8F%8A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%88%86%E5%8C%BA%2F","content":"\n# 磁盘储存\n\n设备类型：\n块设备：block，存取单位“块”，磁盘\n字符设备：char，存取单位“字符”，键盘\n\n### 机械硬盘和固态硬盘\n\n**机械硬盘（HDD）：**\n&emsp;Hard Disk Drive，即是传统普通硬盘，主要由：盘片，磁头，盘片转轴及控制电机，磁头控制器，数据转换器，接口，缓存等几个部分组成。机械硬盘中所有的盘片都装在一个旋转轴上，每张盘片之间是平行的，在每个盘片的存储面上有一个磁头，磁头与盘片之间的距离比头发丝的直径还小，所有的磁头联在一个磁头控制器上，由磁头控制器负责各个磁头的运动。磁头可沿盘片的半径方向运动，加上盘片每分钟几千转的高速旋转，磁头就可以定位在盘片的指定位置上进行数据的读写操作。数据通过磁头由电磁流来改变极性方式被电磁流写到磁盘上，也可以通过相反方式读取。硬盘为精密设备，进入硬盘的空气必须过滤\n**固态硬盘（SSD）**：\n&emsp;Solid State Drive，用固态电子存储芯片阵列而制成的硬盘，由控制单元和存储单元（FLASH芯片、DRAM芯片）组成。固态硬盘在接口的规范和定义、功能及使用方法上与普通硬盘的完全相同，在产品外形和尺寸上也与普通硬盘一致\n相较于HDD，SSD在防震抗摔、传输速率、功耗、重量、噪音上有明显优势，SSD传输速率性能是HDD的2倍\n相较于SSD，HDD在价格、容量、使用寿命上占有绝对优势\n硬盘有价，数据无价，目前SSD不能完全取代HHD\n\n**设备文件**\n磁盘设备的设备文件命名：\n>/dev/DEV_FILE\nSCSI, SATA, SAS,IDE,USB: /dev/sd\n虚拟磁盘：/dev/vd\n不同磁盘标识：a-z,aa,ab…\n/dev/sda, /dev/sdb, ...\n同一设备上的不同分区：1,2, ...\n/dev/sda1, /dev/sda5\n硬盘存储术语\nhead：磁头\ntrack：磁道\ncylinder: 柱面\nsector: 扇区，512bytes\n\n**分区**\n两种分区方式：MBR，GPT\n>MBR: Master Boot Record，1982年，使用32位表示扇区数，分区不超过2T\n如何分区：按柱面\n0磁道0扇区：512bytes\n446bytes: boot loader\n64bytes：分区表，其中每16bytes标识一个分区\n2bytes: 55AA\n4个主分区；3主分区+1扩展(N个逻辑分区)\n\n**MBR分区结构**\n\n&emsp;硬盘主引导记录MBR由4个部分组成:\n1. 主引导程序（偏移地址0000H--0088H），它负责从活动分区中装载，并运行系统引导程序\n2. 出错信息数据区，偏移地址0089H--00E1H为出错信息，00E2H--01BDH全为0字节\n3. 分区表（DPT,Disk Partition Table）含4个分区项，偏移地址01BEH--01FDH,每个分区表项长16个字节，共64字节为分区项1、分区项2、分区项3、分区项4\n4. 结束标志字，偏移地址01FE--01FF的2个字节值为结束标志55AA\n\n**GPT分区**\n\nGPT:GUID（Globals Unique Identifiers）partition table 支持128个分区，使用64位，支持8Z（512Byte/block ）64Z （4096Byte/block）\n使用128位UUID(Universally Unique Identifier) 表示磁盘和分区GPT分区表自动备份在头和尾两份，并有CRC校验位\nUEFI (统一扩展固件接口)硬件支持GPT，使操作系统启动\n\n**管理分区**\n```bash\n列出块设备\n•lsblk\n创建分区使用：\n•fdisk创建MBR分区\n•gdisk创建GPT分区\n•parted高级分区操作\n重新设置内存中的内核分区表版本\n•partprobe\n```\nparted命令\n\nparted的操作都是**实时生效**的，小心使用\n用法：\n```bash\nparted [选项]... [设备[命令[参数]...]...]\nparted /dev/sdbmklabelgpt|msdos\nparted /dev/sdbprint\nparted /dev/sdbmkpartprimary 1 200 （默认M）\nparted /dev/sdbrm1\nparted –l 列出分区信息\n```\n# 分区工具fdisk和gdisk\n```bash\ngdisk/dev/sdb类fdisk的GPT分区工具\nfdisk-l [-u] [device...] 查看分区\nfdisk/dev/sdb管理分区\n子命令：\np 分区列表\nt 更改分区类型\nn 创建新分区\nd 删除分区\nv 校验分区\nu 转换单位\nw 保存并退出\nq 不保存并退出\n```\n同步分区表\n\n查看内核是否已经识别新的分区\ncat /proc/partations\ncentos6通知内核重新读取硬盘分区表\n新增分区用\n```bash\npartx -a /dev/DEVICE\nkpartx -a /dev/DEVICE -f: force\n```\n删除分区用\n```bash\npartx-d --nrM-N /dev/DEVICE\nCentOS 5，7: 使用partprobe\npartprobe[/dev/DEVICE]\n```\n\n## 文件系统类型\n\nLinux文件系统：\n1. ext2(Extended file system) :适用于那些分区容量不是太大，更新也不频繁的情况，例如/boot 分区\n2. ext3:是ext2 的改进版本，其支持日志功能，能够帮助系统从非正常关机导致的异常中恢复。它通常被用作通用的文件系统\n3. ext4:是ext 文件系统的最新版。提供了很多新的特性，包括纳秒级时间戳、创建和使用巨型文件(16TB)、最大1EB的文件系统，以及速度的提升\n>xfs：SGI，支持最大8EB的文件系统\nbtrfs（Oracle）, reiserfs, jfs（AIX）, swap\n光盘：iso9660\nWindows：FAT32, exFAT,NTFS\nUnix: FFS（fast）, UFS（unix）, JFS2\n网络文件系统：NFS, CIFS\n集群文件系统：GFS2, OCFS2（oracle）\n分布式文件系统：fastdfs,ceph, moosefs, mogilefs, glusterfs, Lustre\nRAW：未经处理或者未经格式化产生的文件系统\n\n## 文件系统分类\n\n根据其是否支持\"journal\"功能：\n日志型文件系统: ext3, ext4, xfs, ...\n非日志型文件系统: ext2, vfat\n文件系统的组成部分：\n内核中的模块：ext4, xfs, vfat\n用户空间的管理工具：mkfs.ext4, mkfs.xfs,mkfs.vfat\nLinux的虚拟文件系统：VFS\n查前支持的文件系统：cat /proc/filesystems\n\n## 创建ext文件系统\n```bash\nmke2fs：ext系列文件系统专用管理工具\n-t {ext2|ext3|ext4} 指定文件系统类型\n-b {1024|2048|4096} 指定块大小\n-L ‘LABEL’ 设置卷标\n-j相当于-t ext3\nmkfs.ext3 = mkfs-t ext3 = mke2fs -j = mke2fs -t ext3\n-i#为数据空间中每多少个字节创建一个inode；不应该小于block大小\n-N #指定分区中创建多少个inode\n-I 一个inode记录占用的磁盘空间大小，128---4096\n-m #默认5%,为管理人员预留空间占总空间的百分比\n-O FEATURE[,...]启用指定特性\n-O ^FEATURE关闭指定特性\ntune2fs -l /dev/sdb1|less   查看文件系统的元数据\ndumpe2fs /dev/sdb1|less     查看文件系统的元数据\nFilesystem features: has_journal        journal说明该文件系统有日志功能\n日志型文件系统: ext3, ext4, xfs, ...\n非日志型文件系统: ext2, vfat\nFilesystem state: clean         noclean 时说明文件系统出问题\nfindfs LABEL=<label>|  UUID=<uuid> 如：findfs UUID=6ec4348f-8835-4521-9285-23bc242b6243 查找分区\n```\n\n## 文件系统标签\n\n指向设备的另一种方法\n与设备无关\n```bash\nblkid：块设备属性信息查看\nblkid[OPTION]... [DEVICE]\n-U UUID根据指定的UUID来查找对应的设备\n-L LABEL根据指定的LABEL来查找对应的设备\ne2label：管理ext系列文件系统的LABEL\ne2label DEVICE [LABEL]\nfindfs：查找分区\nfindfs[options] LABEL=<label>\nfindfs[options] UUID=<uuid>\n```\ntune2fs\n```bash\ntune2fs：重新设定ext系列文件系统可调整参数的值\n-l查看指定文件系统超级块信息；super block\n-L 'LABEL‘修改卷标\n-m #修预留给管理员的空间百分比\n-j将ext2升级为ext3\n-O文件系统属性启用或禁用,–O ^has_journal\n-o调整文件系统的默认挂载选项，–o ^acl\n-U UUID修改UUID号\ndumpe2fs：\n块分组管理，32768块\n-h：查看超级块信息，不显示分组信息\n```\n\n## 文件系统检测和修复\n\n常发生于死机或者非正常关机之后\n挂载为文件系统标记为“no clean”\n注意：**一定不要在挂载状态下修复**\nfsck: File System Check\nfsck.FS_TYPE\nfsck -t FS_TYPE\n\n-p自动修复错误\n-r交互式修复错误\nFS_TYPE一定要与分区上已经文件类型相同\ne2fsck：ext系列文件专用的检测修复工具\n-y自动回答为yes\n-f强制修复\n\n# 实验：增加一块新硬盘，分区，创建文件系统XFS|EXT4，并挂载\n*****************************************************************************************\nVMware中添加一块200G硬盘，重启虚拟机\n输入lsblk查看多了一个sdb 硬盘\n```bash\nfdisk /dev/sdb\nCommand (m for help): m\nCommand action\n   a   toggle a bootable flag\n   b   edit bsd disklabel\n   c   toggle the dos compatibility flag\n   d   delete a partition                                  删除一个分区\n   g   create a new empty GPT partition table\n   G   create an IRIX (SGI) partition table\n   l   list known partition types\n   m   print this menu\n   n   add a new partition                                 创建一个分区\n   o   create a new empty DOS partition table\n   p   print the partition table                          查看分区信息\n   q   quit without saving changes\n   s   create a new empty Sun disklabel\n   t   change a partition's system id\n   u   change display/entry units\n   v   verify the partition table\n   w   write table to disk and exit                        保存写入分区操作信息，不按w分区不保存\n   x   extra functionality (experts only)\n按m进入交互式操作\n按n新建一个分区，如下\nCommand (m for help): n\nPartition type:\n   p   primary (0 primary, 0 extended, 4 free)       主分区\n   e   extended                                      扩展分区\nSelect (default p): p\nPartition number (1-4, default 1): 1                  分区编号\nFirst sector (2048-41943039, default 2048): \nUsing default value 2048\nLast sector, +sectors or +size{K,M,G} (2048-41943039, default 41943039): +50G      分区大小            \nPartition 1 of type Linux and of size 1 GiB is set\n\nCommand (m for help): p                                             显示分区信息\n\nDisk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectors\nUnits = sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\nDisk label type: dos\nDisk identifier: 0x1cc76008\n\n   Device Boot      Start         End      Blocks   Id  System\n/dev/sdb1            2048     2099199     1048576   83  Linux\n然后按w保存分区信息**************************\n```\n分区完成 \n若lsblk后没有新建的分区，可以输入partx -a /dev/sdb  来通知内核重新读取分区表  或者输入partprobe 进行分区同步\n\n## 挂载mount\n\n挂载:将额外文件系统与根文件系统某现存的目录建立起关联关系，进而使得此目录做为其它文件访问入口的行为\n卸载:为解除此关联关系的过程\n把设备关联挂载点：mount Point\nmount\n卸载时：可使用设备，也可以使用挂载点\numount\n挂载点下原有文件在挂载完成后会被临时隐藏\n挂载点目录一般为空\n\n用mount命令挂载文件系统\n```bash\n#挂载方法：\nmount DEVICE MOUNT_POINT\nmount 通过查看/etc/mtab文件显示当前已挂载的所有设备\nmount [-fnrsvw] [-t vfstype] [-o options] device dir\n```\ndevice：指明要挂载的设备；\n>(1) 设备文件：例如/dev/sda5\n(2) 卷标：-L 'LABEL', 例如-L 'MYDATA'\n(3) UUID, -U 'UUID'：例如-U '0c50523c-43f1-45e7-85c0-a126711d406e'\n(4) 伪文件系统名称：proc, sysfs, devtmpfs, configfs\ndir：挂载点\n事先存在；建议使用空目录\n进程正在使用中的设备无法被卸载\n\nmount常用命令选项\n```bash\nmount\n-t vsftype指定要挂载的设备上的文件系统类型\n-rreadonly，只读挂载\n-wread and write, 读写挂载\n-n不更新/etc/mtab，mount不可见\n-a自动挂载所有支持自动挂载的设备(定义在了/etc/fstab文件中，且挂载选项中有auto功能)\n-L 'LABEL' 以卷标指定挂载设备\n-U 'UUID' 以UUID指定要挂载的设备\n-B, --bind绑定目录到另一个目录上\n```\n查看内核追踪到的已挂载的所有设备\n```bash\ncat /proc/mounts\n-o options：(挂载文件系统的选项)，多个选项使用逗号分隔\n.>async  异步模式sync同步模式,内存更改时，同时写磁盘\natime/noatime   包含目录和文件\ndiratime/nodiratime  目录的访问时间戳\nauto/noauto   是否支持自动挂载,是否支持-a选项\nexec/noexec  是否支持将文件系统上运行应用程序\ndev/nodev   是否支持在此文件系统上使用设备文件\nsuid/nosuid   是否支持suid和sgid权限\nremount   重新挂载\nro只读rw读写\nuser/nouser  是否允许普通用户挂载此设备，/etc/fstab使用\nacl  启用此文件系统上的acl功能\nloop  使用loop设备\ndefaults：相当于rw, suid, dev, exec, auto, nouser, async\n```\n\n## 查询设备\n```bash\n#blkid 查询各个设备UUID\nmount -U 'UUID' 加挂载点  挂载设备\numount /mnt/sdb1  卸载挂载设备sdb1（无占用）  \nlsof /mnt/sdb1   有用户占用时，查询sdb1占用进程和用户\nfuser -km /mnt/sdb1  结束sdb1的所有占用\ncat /proc/mounts 查询所有的挂载点\numount -o remount +挂载点 重新挂载，某些设备不能取消挂载\n```\n# 实验：迁移/home目录到新分区中\n```bash\n#先添加一块新的硬盘，重启虚拟机\nlsblk看到新硬盘为sdc\nfdisk /dev/sdc  新建一个分区sdc1\nblkid\nmkfs.xfs /dev/sdc1  创建文件系统\nmkdir /mnt/home  创建新的挂载点\nmount /dev/sdc1 /mnt/home  将光盘进行挂载\ncp -av /home/. /mnt/home 将原来home下的所有文件复制到/mnt/home下\nll mnt/home\ndu -sh /mnt/home\ndu -sh /home   比较两文件夹的大小，看复制是否完整\nvim /etc/fstab 命令模式下写入:r!blkid /dev/sdc1 修改后按wq保存退出\nmount -a 使挂载生效\ndf -h   查看占用\numount /home 取消挂载\nrm -rf /home/* 删除home中的文件\n\n```","tags":["L·H"]},{"title":"实验 ：源码编译安装httpd-2.4.25.tar.bz2","url":"%2F2018%2F10%2F05%2F%E5%AE%9E%E9%AA%8C%20%EF%BC%9A%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85httpd-2.4.25.tar.bz2%2F","content":"\n# 实验 ：源码编译安装httpd-2.4.25.tar.bz2\n```bash\n1.\tyum groupinstall \"development tools\"\n2.\tyum install apr-devel apr-util-devel pcre-devel openssl-devel\n3.\tuseradd -r -u 80 -d /data/www/ -s /sbin/nologin httpd\n4.\tmkdir httpd\n5.\tcd httpd\n6.\trz 选择httpd-2.4.25.tar.bz2\n7.\ttar xf httpd-2.4.25.tar.bz2\n8.\tcd httpd-2.4.25/\n9.\tcat README  #查看安装介绍\n10.\tcat INSTALL   #查看功能帮助介绍\n11.\t./configure --prefix=/app/httpd --sysconfdir=/etc/httpd24 --enable-ssl --disable-status\n12.\tmake && make install\n13.\techo 'PATH=/app/httpd/bin:$PATH' > /etc/profile.d/httpd.sh\n14.\t. /etc/profile.d/httpd.sh\n15.\tapachectl start\n16.\t#然后查询网卡信息，在浏览器输入桥接地址看是否出现it works!\n17.\t#修改it works!，可用vim /root/http/httpd-2.4.25/docs/docroot/index.html，修改index.html\n18. echo ‘PATH=/app/httpd/bin:$PATH’ > /etc/profile.d/httpd.sh\n添加将路径添加到PATH变量\n\n```\n\n# 编译安装\n编译安装\n1. .configure               ********配置\n(1) 通过选项传递参数，指定启用特性、安装路径等；执行时会参考用户的指定以及Makefile.in文件生成Makefile\n2、make 根据Makefile文件，构建应用程序  ***********编译\n3、make install 复制文件到相应路径  **************安装\ndu -sh 查看当前目录占用空间大小\n*******************************************************","tags":["L·H"]},{"title":"软连接和硬链接的区别","url":"%2F2018%2F10%2F04%2F%E8%BD%AF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB%2F","content":"\n**软连接和硬链接的区别:**\n1. 两个文件若互为对方的硬链接，则这两个文件指向同一个 inode，如果删除了其中一个，对另外一个没有影响。\n2. 每增加一个硬链接，inode 节点上的链接数增加一，每删除一个硬链接，inode 节点上的链接数减一，直到为 0，inode 节点和对应的数据块被回收。\n3. 若 A 文件是 B 文件的软连接，则 A 和 B 分别是不同的文件，指向的 inode 节点号也不相同，但是 A 文件的 inode指向的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。\n**硬链接的特点：**\n1：不能对目录创建硬链接\n2：不能对不同的文件系统创建硬链接,即两个文件名要在相同的文件系统下。\n3：不能对不存在的文件创建硬链接\n**软连接的特点：**\na.可以对目录创建软链接，遍历操作会忽略目录的软链接。\nb:可以跨文件系统\nc:可以对不存在的文件创建软链接","tags":["L·H"]},{"title":"实验：实现swap分区","url":"%2F2018%2F10%2F03%2F%E5%AE%9E%E9%AA%8C%EF%BC%9A%E5%AE%9E%E7%8E%B0swap%E5%88%86%E5%8C%BA%2F","content":"\n# 实验：实现swap分区\nswap 相当于虚拟内存，交换分区\n本实验为增加swap分区大小\n```bash\n#新建一个分区\n[root@CentOS6 ~]#fdisk /dev/sdb                添加硬盘sdb\n\nWARNING: DOS-compatible mode is deprecated. It's strongly recommended to\n         switch off the mode (command 'c') and change display units to\n         sectors (command 'u').\n\nCommand (m for help): n                    #新建分区\nCommand action\n   e   extended\n   p   primary partition (1-4)\n                        p                #e为逻辑分区，p为主分区\nPartition number (1-4): 2                #设定分区编号\nFirst cylinder (6529-26108, default 6529):          #回车\nUsing default value 6529\nLast cylinder, +cylinders or +size{K,M,G} (6529-26108, default 26108): +4G #分区大小为4G\nCommand (m for help): p\n\nDisk /dev/sdb: 214.7 GB, 214748364800 bytes\n255 heads, 63 sectors/track, 26108 cylinders\nUnits = cylinders of 16065 * 512 = 8225280 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\nDisk identifier: 0x7972ac2c\n\n   Device Boot      Start         End      Blocks   Id  System\n/dev/sdb1               1        6528    52436128+  83  Linux\n/dev/sdb2            6529        7051     4200997+  83  Linux\n\nCommand (m for help): t                    #修改分区信息\nPartition number (1-4): 2\nHex code (type L to list codes): 82        #改为swap分区\nChanged system type of partition 2 to 82 (Linux swap / Solaris)\n\nCommand (m for help): p\n\nDisk /dev/sdb: 214.7 GB, 214748364800 bytes\n255 heads, 63 sectors/track, 26108 cylinders\nUnits = cylinders of 16065 * 512 = 8225280 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\nDisk identifier: 0x7972ac2c\n\n   Device Boot      Start         End      Blocks   Id  System\n/dev/sdb1               1        6528    52436128+  83  Linux\n/dev/sdb2            6529        7051     4200997+  82  Linux swap / Solaris\n\nCommand (m for help): w                      #保存分区信息\nThe partition table has been altered!\n\nCalling ioctl() to re-read partition table.\n\nWARNING: Re-reading the partition table failed with error 16: Device or resource busy.\nThe kernel still uses the old table. The new table will be used at\nthe next reboot or after you run partprobe(8) or kpartx(8)\nSyncing disks.\n\n分区已创建好\nswapon /dev/sdb2   \nvim /etc/fstab                                     #在其中写入以下信息\nUUID=f2350b40-9169-4ef7-a4d7-c389217e192f swap   swap    pri=10          0 0  # 其中pri=10为取代原来的swap的优先级,原swap优先级为-1\nswapoff        #禁用swap\nswapon -a    #启用swap\ncat /proc/swaps\nswapon -s\nfree -h        #可以看到swap 又原来的2G变为了6G\n```","tags":["L·H"]},{"title":"实验：centos6删除内核并恢复","url":"%2F2018%2F10%2F02%2F%E5%AE%9E%E9%AA%8C%EF%BC%9Acentos6%E5%88%A0%E9%99%A4%E5%86%85%E6%A0%B8%E5%B9%B6%E6%81%A2%E5%A4%8D%2F","content":"实验：centos6 rm -f /boot/vmlinuz-2.6.32-754.el6.x86_64  恢复\n\n\n\nrm -f /boot/vmlinuz-2.6.32-754.el6.x86_64\n重启\n在进度条时按下esc，只能按一下\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20181210190835745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MTE1Mg==,size_16,color_FFFFFF,t_70)\n选择CD-ROM\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20181210190855572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MTE1Mg==,size_16,color_FFFFFF,t_70)\n选择Rescue installed system\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20181210190919170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MTE1Mg==,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20181210190933259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MTE1Mg==,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/201812101909439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MTE1Mg==,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20181210190955473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MTE1Mg==,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20181210191009174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MTE1Mg==,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20181210191019387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MTE1Mg==,size_16,color_FFFFFF,t_70)\n提示根目录被修改为chroot /mnt/sysimage\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20181210191039415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MTE1Mg==,size_16,color_FFFFFF,t_70)\n进入shell\n创建挂载点并挂载光盘\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20181210191100625.png)\n因为vmlinuz-2.6.32-754.el6.x86_64在kernel包里，所以安装kernel包，并用—root告诉它根在/mnt/sysimage\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20181210191131413.png)\n查看/boot下生成了vmlinuz-2.6.32-754.el6.x86_64文件\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20181210191157682.png)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20181210191206556.png)\n输入exit退出shell\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20181210191226233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU1MTE1Mg==,size_16,color_FFFFFF,t_70)\nReboot重启\n","tags":["L·H"]},{"title":"文本处理及文件查找","url":"%2F2018%2F10%2F02%2F%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%8F%8A%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%2F","content":"\n# 文本处理及正则表达式\n###   文件查看\n文件查看命令：  \ncat，tac，rev\ncat [OPTION]... [FILE]...  \n-E：显示行结束符$  \n-n：对显示出的每一行进行编号  \n-A：显示所有控制符  \n-b：非空行编号  \n-s：压缩连续的空行成一行  \ntac  \nrev  \n文件查看  \nmore: 分页查看文件  \nmore [OPTIONS...] FILE...  \n-d: 显示翻页及退出提示  \nless：一页一页地查看文件或STDIN输出  \n查看时有用的命令包括：  \n/文本搜索文本  \nn/N跳到下一个或上一个匹配  \nless命令是man命令使用的分页器  \n###  显示文本前或后行内容*********************************************  \nhead [OPTION]... [FILE]...  \n-c #: 指定获取前#字节  \n-n #: 指定获取前#行  \n-#：指定行数  \ntail [OPTION]... [FILE]...  \n-c #: 指定获取后#字节  \n-n #: 指定获取后#行  \n-#：同上  \n-f: 跟踪显示文件fd新追加的内容,常用日志监控  \n相当于--follow=descriptor  \n-F: 跟踪文件名，相当于--follow=name --retry  \ntailf类似tail –f，当文件不增长时并不访问文件  \n###按列抽取文本cut和合并文件paste***************************************CUT  \ncut [OPTION]... [FILE]...  \n-d DELIMITER: 指明分隔符，默认tab  \n-f FILEDS:  \n...#: 第#个字段  \n...#,#[,#]：离散的多个字段，例如1,3,6  \n...#-#：连续的多个字段, 例如1-6  \n混合使用：1-3,7  \n-c按字符切割  \n--output-delimiter=STRING指定输出分隔符  \ncut和paste  \n显示文件或STDIN数据的指定列  \ncut-d:-f1/etc/passwd  \ncat /etc/passwd|cut-d:-f7  \ncut-c2-5/usr/share/dict/words  \npaste 合并两个文件同行号的列到一行  \npaste [OPTION]... [FILE]...  \n-d 分隔符：指定分隔符，默认用TAB  \n-s : 所有行合成一行显示  \n示例：  \npaste f1 f2  \npaste -s f1 f2\n### 收集文本统计数据wc*****************************************WC  \n计数单词总数、行总数、字节总数和字符总数  \n可以对文件或STDIN中的数据运行  \nwcstory.txt  \n392371901story.txt  \n行数字数字节数  \n常用选项  \n>-l只计数行数  \n>-w只计数单词总数  \n>-c只计数字节总数  \n>-m只计数字符总数  \n>-L显示文件中最长行的长度  \n### 文本排序sort  \n把整理过的文本显示在STDOUT，不改变原始文件  \nsort[options]file(s)\n常用选项  \n>-r执行反方向（由上至下）整理\n>-R随机排序  \n>-n执行按数字大小整理  \n>-f选项忽略（fold）字符串中的字符大小写  \n>-u选项（独特，unique）删除输出中的重复行  \n>-t c选项使用c做为字段界定符  \n>-k X选项按照使用c字符分隔的X列来整理能够使用多次  \n### uniq\nuniq命令：从输入中删除前后相接的重复的行  \nuniq[OPTION]... [FILE]...  \n-c: 显示每行重复出现的次数  \n-d: 仅显示重复过的行  \n-u: 仅显示不曾重复的行  \n注：连续且完全相同方为重复  \n常和sort 命令一起配合使用：  \nsort userlist.txt | uniq-c  \n### 比较文件\n比较两个文件之间的区别  \ndifffoo.conffoo2.conf  \n5c5 \n< use_widgets=no\n.>use_widgets=yes\n注明第5行有区别（改变）\n##  取出IP地址的几种方法： *************************************（重点）\n>ifconfig | sed -r '2!d;s/.*inet (addr:)?//;s/ .*//'  6和7通用的取出IP地址    \nifconfig eth0 | head -2|tail -1| tr -dc '[0-9]. ' |tr -s ' ' |cut -d\" \" -f2   6系统上  \nifconfig eth0|sed -n '2p'|sed 's@.*inet @@'|sed 's@ netmask.$@@' 提取出7上的IP地址，其中@@为分隔符  \nifconfig ens33|sed -nr '2s/.*t (.*) net.*/\\1/gp' 扩展的正则表达式取出IP，（）为分组，只有一个括号，所以后面写1  \nifconfig ens33|sed -nr '2s/（.*t) (.*)( net.*)/\\2/gp' 扩展的正则表达式取出IP，（）为分组，有三个括号，所以后面写2留第二个  \nifconfig | sed -nr \"s/.inet (.*) netmask.*/\\1/p\" | head -n 1   取出7的IP  \nifconfig | sed -nr \"s/.inet (.*) netmask.*/\\1/p\" 取出7的三个网卡IP  \n## 查询系统信息  ***********************************************重点  \n..#RED is content color  \n..#依次显示出  \n..#系统版本  \n..#内核版本  \n..#CPU型号  \n..#内存大小  \n..#最大磁盘利用率  \n..#hostname  \n..#IP地址  \n>RED=\"\\033[1;31m\"  \nCOLOREND=\"\\033[0m\"  \n>echo -e \"OS version is $RED`cat /etc/centos-release`$COLOREND\"  \necho -e \"kernel version $RED`uname -r`$COLOREND\"  \necho -e \"The cpu type is $RED`lscpu |egrep -i 'model name'|tr -s ' '|cut -d: -f2`$COLOREND\"  \necho -e \"The memory is $RED`free -h|egrep Mem|tr -s ' ' ':' |cut -d: -f2`$COLOREND\"  \necho -e \"The max disk used is $RED`df |grep  /dev/sd|tr -s \" \" \":\"|cut -d: -f5|sort -nr|head -1`$COLOREND\"    \necho -e \"The hostname is $RED$(hostname)$COLOREND\"  \necho -e \"The ipaddr is $RED`ifconfig|head -2|tail -1|tr -s \" \" \":\"|cut -d: -f3`$COLOREND\"  \nunset RED COLOREND  \n# Linux文本处理三剑客\ngrep：文本过滤(模式：pattern)工具  \ngrep, egrep, fgrep（不支持正则表达式搜索）  \nsed：stream editor，文本编辑工具  \nawk：Linux上的实现gawk，文本报告生成器  \n## grep*************************************************(重点)\ngrep: Global search REgularexpression and Print out the line  \n作用：文本搜索工具，根据用户指定的“模式”对目标文本逐行进行匹配检查；打印匹配到的行  \n模式：由正则表达式字符及文本字符所编写的过滤条件  \n>grep [OPTIONS] PATTERN [FILE...]  \ngrep root /etc/passwd  \ngrep \"$USER\" /etc/passwd  \ngrep '$USER' /etc/passwd  \ngrep `whoami` /etc/passwd  \ngrep命令选项  \n--color=auto: 对匹配到的文本着色显示  \n-v: 显示不被pattern匹配到的行  \n-i: 忽略字符大小写  \n-n：显示匹配的行号  \n-c: 统计匹配的行数  \n-o: 仅显示匹配到的字符串  \n-q: 静默模式，不输出任何信息  \n-A #: after, 后#行  \n-B #: before, 前#行  \n-C #：context, 前后各#行  \n-e：实现多个选项间的逻辑or关系  \ngrep –e ‘cat ’ -e ‘dog’ file  \n-w：匹配整个单词  \n-E：使用ERE  \n-F：相当于fgrep，不支持正则表达式  \n-ffile: 根据模式文件处理  \n\n# 正则表达式*************************************重点\nREGEXP：Regular Expressions，由一类特殊字符及文本字符所编写的模式，其中有些字符（元字符）不表示字符字面意义，而表示控制或通配的功能  \n程序支持：grep,sed,awk,vim, less,nginx,varnish等  \n分两类：  \n基本正则表达式：BRE  \n扩展正则表达式：ERE  \ngrep -E, egrep  \n正则表达式引擎：  \n采用不同算法，检查处理正则表达式的软件模块  \nPCRE（Perl Compatible Regular Expressions）  \n元字符分类：字符匹配、匹配次数、位置锚定、分组  \nman 7 regex    \n### 基本正则表达式元字符  \n字符匹配:  \n. 匹配任意单个字符  \n[] 匹配指定范围内的任意单个字符，示例：[wang] [0-9] [a-z] [a-zA-Z]  \n[^] 匹配指定范围外的任意单个字符  \n[:alnum:] 字母和数字  \n[:alpha:] 代表任何英文大小写字符，亦即A-Z, a-z  \n[:lower:] 小写字母[:upper:] 大写字母  \n[:blank:] 空白字符（空格和制表符）  \n[:space:]水平和垂直的空白字符（比[:blank:]包含的范围广）  \n[:cntrl:] 不可打印的控制字符（退格、删除、警铃...）  \n[:digit:] 十进制数字[:xdigit:]十六进制数字  \n[:graph:] 可打印的非空白字符  \n[:print:] 可打印字符  \n[:punct:] 标点符号  \n### 通配符是通配的文件名  \n正则表达式是配的字符串，文件的内容  \n【wang】 匹配这四个字符其中的一个  \ngrep \"[123]\" /etc/passwd查询passwd文件夹里包含123中一个数字的文件  \ngrep -v \"[123]\" /etc/passwd查询passwd文件夹里不包含123中一个数字的文件  \ngrep \"[^123]\" /etc/passwd查询passwd文件夹里除了123中一个数字的文件  \n匹配次数：用在要指定次数的字符后面，用于指定前面的字符要出现的次数  \n‘* 匹配前面的字符任意次，包括0次  \n贪婪模式：尽可能长的匹配  \n.*任意长度的任意字符  \n\\?匹配其前面的字符0或1次  \n\\+匹配其前面的字符至少1次  \n\\{n\\}匹配前面的字符n次  \n\\{m,n\\}匹配前面的字符至少m次，至多n次  \n\\{,n\\}匹配前面的字符至多n次  \n\\{n,\\}匹配前面的字符至少n次   \n### 位置锚定：定位出现的位置  \n^ 行首锚定，用于模式的最左侧 grep \"^bash\" /etc/passwd  \n$ 行尾锚定，用于模式的最右侧 grep \"bash$\" /etc/passwd  \n^PATTERN$ 用于模式匹配整行  \n^$ 空行  \n^[[:space:]]*$ 空白行  \n\\< 或\\b词首锚定，用于单词模式的左侧(单词不能包含数字、_、其他字母开头)  \n\\> 或\\b词尾锚定，用于单词模式的右侧  \n\\<PATTERN\\>匹配整个单词***************************************************  \n### 正则表达式\n分组：\\(\\) 将一个或多个字符捆绑在一起，当作一个整体处理，如：\\(root\\)\\+  \n分组括号中的模式匹配到的内容会被正则表达式引擎记录于内部的变量中，这些变量的命名方式为: \\1, \\2, \\3, ...  \n\\1表示从左侧起第一个左括号以及与之匹配右括号之间的模式所匹配到的字符  \n示例：\\(string1\\+\\(string2\\)*\\)  \n\\1 ：string1\\+\\(string2\\)*  \n\\2 ：string2  \n后向引用：引用前面的分组括号中的模式所匹配字符，而非模式本身  \n或者：\\|  \n示例：a\\|b: a或b C\\|cat: C或cat \\(C\\|c\\)at:Cat或cat  \n元字符  \n>^ 行首    \n`$`行尾  \n.任意单一字符    \n[][]内任意单一字符    \n[^]除[]内任意单一字符   \n**前面字符重复不确定次数    \n\\+\\+前面字符重复一次以上不确定次数  \n\\?？前面字符重复0或1次  \n\\转义符  \n.*任意长度字符  \n\\{n\\}前面字符重复n次  \n\\{n,\\}前面字符重复n次以上  \n\\{m,n\\}前面字符重复m次和n次之间  \n[:alnum:]字母和数字  \n[:alpha:]代表任何英文大小写字符，亦即A-Z, a-z  \n[:lower:]小写字母  \n[:upper:]大写字母  \n[:blank:]水平空白字符（空格和制表符）  \n[:space:]所有水平和垂直的空白字符（比[:blank:]包含的范围广）  \n[:cntrl:]不可打印的控制字符（退格、删除、警铃...）  \n[:digit:]十进制数字  \n[:graph:]可打印的非空白字符  \n[:print:]可打印字符  \n[:punct:]标点符号  \n[:xdigit:]十六进制数字    \n## egrep及扩展的正则表达式\negrep= grep -E  \negrep[OPTIONS] PATTERN [FILE...]  \n扩展正则表达式的元字符：  \n字符匹配：  \n. 任意单个字符  \n[] 指定范围的字符  \n[^] 不在指定范围的字符  \n次数匹配：  \n*匹配前面字符任意次  \n?0或1次  \n+1次或多次  \n{m}匹配m次  \n{m,n}至少m，至多n次  \n位置锚定：  \n^行首   \n$行尾  \n\\<, \\b语首  \n\\>, \\b语尾  \n分组：()  \n后向引用：\\1, \\2, ...  \n或者：  \na|ba或b  \nC|catC或cat  \n(C|c)atCat或cat  \n\n# vim简介*************************************重点  \n见PDF6中第32，68，69页图片   \nvi: Visual Interface，文本编辑器  \n文本：ASCII, Unicode  \n文本编辑种类：  \n行编辑器: sed  \n全屏编辑器：nano, vi  \nvim-Vi Improved  \n其他编辑器：  \ngedit一个简单的图形编辑器  \ngvim一个Vim编辑器的图形版本  \n### 打开文件\nvim [OPTION]... FILE...  \n+#打开文件后，让光标处于第#行的行首，+默认行尾  \n+/PATTERN打开文件后，直接让光标处于第一个被PATTERN匹配到的行的行首  \n–b file 二进制方式打开文件  \n–d file1 file2… 比较多个文件  \n-m file 只读打开文件  \nex file 或vim –e 直接进入ex模式  \n如果该文件存在，文件被打开并显示内容  \n如果该文件不存在，当编辑后第一次存盘时创建它  \n模式转换  \n命令模式--> 插入模式  \niinsert, 在光标所在处输入  \nI在当前光标所在行的行首输入  \naappend, 在光标所在处后面输入  \nA在当前光标所在行的行尾输入  \no在当前光标所在行的下方打开一个新行  \nO在当前光标所在行的上方打开一个新行  \n\n*******************************************************\n插入模式--------> 命令模式  \nESC  \n命令模式--------> 扩展命令模式  \n:  \n扩展命令模式--------> 命令模式  \nESC,enter  \n************************************************************\n扩展命令模式：  \n:q退出  \n:q!强制退出，丢弃做出的修改  \n:wq保存退出  \n:x保存退出  \n命令模式  \nZZ保存退出  \nZQ不保存退出  \n命令模式光标跳转  \n字符间跳转：  \nh: 左l: 右j: 下k: 上  \n.#COMMAND：跳转由#指定的个数的字符******************  \n### 单词间跳转：\nw：下一个单词的词首  \ne：当前或下一单词的词尾  \nb：当前或前一个单词的词首  \n。#COMMAND：由#指定一次跳转的单词数  \n当前页跳转：  \nH：页首M：页中间行L:页底  \nzt：将光标所在当前行移到屏幕顶端  \nzz：将光标所在当前行移到屏幕中间  \nzb：将光标所在当前行移到屏幕底端  \n行首行尾跳转：  \n^: 跳转至行首的第一个非空白字符  \n0: 跳转至行首  \n`$`: 跳转至行尾  \n行间移动：  \n.#G、扩展命令模式下：# 跳转至由#指定行  \nG：最后一行  \n1G, gg: 第一行  \n句间移动：  \n)：下一句(：上一句  \n段落间移动：  \n}:下一段{：上一段  \n命令模式翻屏操作  \nCtrl+f: 向文件尾部翻一屏    \nCtrl+b: 向文件首部翻一屏  \nCtrl+d: 向文件尾部翻半屏  \nCtrl+u：向文件首部翻半屏  \n### 命令模式操作**********************************************重点  \n删除命令：  \nd: 删除命令，可结合光标跳转字符，实现范围删除  \nd`$`: 删除到行尾  \nd^:删除到非空行首  \nd0:删除到行首  \ndw:  \nde:  \ndb:  \n.#COMMAND  \ndd: 删除光标所在的行  \n.#dd：多行删除  \nD：从当前光标位置一直删除到行尾，等同于d$  \n复制命令(y, yank)：  \ny: 复制，行为相似于d命令\ny$  \ny0  \ny^  \nye  \nyw  \nyb  \n.#COMMAND  \nyy：复制行  \n.#yy: 复制多行  \nY: 复制整行  \n### 命令模式\ndi\" 光标在”“之间，则删除”“之间的内容  \nyi( 光标在()之间，则复制()之间的内容  \nvi[ 光标在[]之间，则选中[]之间的内容  \ndtx删除字符直到遇见光标之后的第一个x 字符  \nytx复制字符直到遇见光标之后的第一个x 字符  \n扩展命令模式：地址定界********************按ESC进入命令模式，再按：进入扩展命令模式  \n### 地址定界\n:start_pos,end_pos  \n`# 具体第#行，例如2表示第2行  \n`#,# 从左侧#表示起始行，到右侧#表示结尾行  \n`#,+# 从左侧#表示的起始行，加上右侧#表示的行数  \n：2,+3 表示2到5行  \n. 当前行  \n`$` 最后一行  \n.,`$`-1 当前行到倒数第二行  \n% 全文, 相当于1,$  \n/pat1/,/pat2/  \n从第一次被pat1模式匹配到的行开始，一直到第一次被pat2匹配到的行结束  \n#,/pat/  \n/pat/,$  \n使用方式：后跟一个编辑命令  \nd  \ny  \nw file: 将范围内的行另存至指定文件中  \nr file：在指定位置插入指定文件中的所有内容  \n/PATTERN：从当前光标所在处向文件尾部查找  \n?PATTERN：从当前光标所在处向文件首部查找  \nn：与命令同方向  \nN：与命令反方向  \n***\n## s: 在扩展模式下完成查找替换操作************************************重点\n格式：s/要查找的内容/替换为的内容/修饰符  \n要查找的内容：可使用模式  \n替换为的内容：不能使用模式，但可以使用\\1, \\2, ...等后向引用符号；还可以使用“&”引用前面查找时查找到的整个内容  \n修饰符：  \ni: 忽略大小写  \ng: 全局替换；默认情况下，每一行只替换第一次出现  \ngc:全局替换，每次替换前询问  \n查找替换中的分隔符/可替换为其它字符，例如  \ns@/etc@/var@g  \ns#/boot#/#i  \n***\n命令模式：撤消更改  \nu撤销最近的更改  \n#u撤销之前多次更改  \nU撤消光标落在这行后所有此行的更改  \n按Ctrl-r重做最后的“撤消”更改  \n. 重复前一个操作  \nn.重复前一个操作n次  \n多文件模式  \nvim FILE1 FILE2 FILE3 ...  \n:next 下一个  \n:prev前一个  \n:first 第一个  \n:last 最后一个  \n:wall 保存所有  \n:qall退出所有  \n:wqall  \n***\n### 定制vim的工作特性\n配置文件：永久有效  \n全局：/etc/vimrc***********************  \n个人：~/.vimrc  \n扩展模式：当前vim进程有效  \n(1) 行号  \n显示：set number, 简写为set nu  \n取消显示：set nonumber, 简写为set nonu  \n(2) 忽略字符的大小写  \n启用：set ic  \n不忽略：set noic  \n(3) 自动缩进  \n启用：set ai  \n禁用：set noai  \n(4) 智能缩进  \n启用：smartindent简写set si  \n禁用：set nosi  \n(5) 高亮搜索  \n启用：set hlsearch  \n禁用：set nohlsearch  \n(6) 语法高亮  \n启用：syntax on  \n禁用：syntax off  \n(7) 显示Tab和换行符^I 和$显示  \n启用：set list  \n禁用：set nolist  \n(8) 文件格式  \n启用windows格式：set fileformat=dos  \n启用unix格式：set fileformat=unix  \n简写：set ff=dos|unix  \n(9) 设置文本宽度  \nset textwidth=65 (vimonly)  \nset wrapmargin=15  \n(10) 设置光标所在行的标识线  \n启用：set cursorline，简写cul  \n禁用：set no cursorline  \n(11) 复制保留格式  \n启用：set paste  \n禁用：set nopaste  \n***  \n## SHELL脚本*********************************************重点  \n创建shell脚本  \n第一步：使用文本编辑器来创建文本文件  \n第一行必须包括shell声明序列：#!  \n.#!/bin/bash  \n添加注释  \n注释以#开头  \n第二步：运行脚本  \n给予执行权限，在命令行上指定脚本的绝对或相对路径  \n直接运行解释器，将脚本作为解释器程序的参数运行  \n脚本规范  \n脚本代码开头约定  \n1、第一行一般为调用使用的语言  \n2、程序名，避免更改文件名为无法找到正确的文件  \n3、版本号  \n4、更改后的时间  \n5、作者相关信息  \n6、该程序的作用，及注意事项  \n7、最后是各版本的更新简要说明  \nshell脚本示例  \n#!/bin/bash  \n#------------------------------------------    \n#Filename: hello.sh   \n#Revision: 1.1    \n#Date: 2017/06/01  \n#Author: wang  \n#Email: wang@gmail.com  \n#Website: www.magedu.com  \n#Description: This is the first script  \n#------------------------------------------  \n#Copyright: 2017 wang  \n#License: GPL  \necho “hello world”  \n***\n.vimrc文件在根目录下，修改：vim  .vimrc 文件\n可以修改vim的脚本注释作者等信息*******************************************\n***\n### 局部变量\n变量赋值：name=‘value’  \n可以使用引用value:  \n(1) 可以是直接字串; name=\"root\"  \n(2) 变量引用：name=\"$USER\"  \n\n(3) 命令引用：name=`COMMAND` name=$(COMMAND)  \n变量引用：${name} $name  \n\"\"：弱引用，其中的变量引用会被替换为变量值\n\n''：强引用，其中的变量引用不会被替换为变量值，而保持原字符串  \n显示已定义的所有变量：set  \n删除变量：unset name  \n环境变量   \n变量声明、赋值：  \nexport name=VALUE  \ndeclare -x name=VALUE  \n变量引用：$name, ${name}  \n显示所有环境变量：  \nenv\n\nprintenv  \nexport  \ndeclare -x  \n删除变量：  \nunset name  \n退出状态  \n进程使用退出状态来报告成功或失败  \n0 代表成功，1－255代表失败  \n`$`? 变量保存最近的命令退出状态  \n例如：  \nping-c1-W1hostdown&>/dev/null  \necho$?  \n***\n### 退出状态码***********************************************************8\nbash自定义退出状态码  \nexit [n]：自定义退出状态码  \n注意：脚本中一旦遇到exit命令，脚本会立即终止；终止退出状态取决于exit命令后面的数字  \n注意：如果未给脚本指定退出状态码，整个脚本的退出状态码取决于脚本中执行的最后一条命令的状态码  \n###  算术运算\nbash中的算术运算:help let  \n+, -, *, /, %取模（取余）, **（乘方）  \n实现算术运算：  \n(1) let var=算术表达式  \n(2) var=$[算术表达式]  \n(3) var=$((算术表达式))  \n(4) var=$(expr arg1 arg2 arg3 ...)  \n(5) declare –ivar= 数值  \n(6) echo ‘算术表达式’ | bc  \n乘法符号有些场景中需要转义，如*  \nbash有内建的随机数生成器：$RANDOM（0-32767）  \necho $[$RANDOM%50] ：0-49之间随机数  \n增强型赋值：  \n+=, -=, *=, /=, %=  \nlet varOPERvalue  \n例如:let count+=3  \n自加3后自赋值  \n自增，自减：  \n例子：    \nlet var+=1  \nlet var++  \nlet var-=1  \nlet var--  \nlet n=1+2  \necho $n  \n3  \nn=$（2+3）  \n2  \nexpr 3+4  错误  \nexpr 3 + 4  \n7  \nexpr为命令  3+4为参数之间要有空格************************************  \necho $[RANDOM%100+1] 取1-100之间的随机数 **  \nRANDOM为随机数，除以100得到的余数为0-99，+1后为1-100 *****  \necho $? 查询命令执行结果  \n***  \n& 与  交集****************************************************    \n| 或  并集  \n! 非    \n^ 异或 相同为0 不同为1  \n&& 短路与 两条命令，第一条为真，则执行第二天2条看真假，第一条为假的情况下直接不执行命令    \n|| 短路或 两条命令，第一条为假，则执行第二天2条看真假，第一条为真的情况下直接不执行命令  \n同或 相同为1  不同为0  \n[ \"$str1\" !=\"$str2\" ] 判断两个字符串是否相同  \nbash +x 加sh脚本可以看到脚本运行的过程，可以检查哪里出错  \nexport +定义的变量可使该变量在子进程中也生效  \nfind -name +文件名 查找文件或者安装包  \n***\n### bash的数值测试\n-v VAR  \n变量VAR是否设置  \n数值测试：  \n-gt是否大于  \n-ge是否大于等于  \n-eq是否等于  \n-ne是否不等于  \n-lt是否小于  \n-le是否小于等于  \nBash的文件属性测试  \n### 文件大小测试：\n-s FILE: 是否存在且非空  \n文件是否打开：  \n-t fd: fd文件描述符是否在某终端已经打开  \n-N FILE：文件自从上一次被读取之后是否被修改过  \n-O FILE：当前有效用户是否为文件属主  \n-G FILE：当前有效用户是否为文件属组  \nBash的文件测试  \n### 存在性测试\n-a FILE：同-e  \n-e FILE: 文件存在性测试，存在为真，否则为假  \n存在性及类别测试  \n-b FILE：是否存在且为块设备文件  \n-c FILE：是否存在且为字符设备文件  \n-d FILE：是否存在且为目录文件  \n-f FILE：是否存在且为普通文件  \n-h FILE 或-L FILE：存在且为符号链接文件  \n-p FILE：是否存在且为命名管道文件  \n-S FILE：是否存在且为套接字文件  \n***\n使用read命令来接受输入  \n使用read来把输入值分配给一个或多个shell变量  \n-p指定要显示的提示  \n-s 静默输入，一般用于密码  \n-n N指定输入的字符长度N  \n-d‘字符’ 输入结束符  \n-t N TIMEOUT为N秒  \nread从标准输入中读取值，给每个单词分配一个变量  \n所有剩余单词都被分配给最后一个变量  \nread -p “Enter a filename:“ FILE  \n***\n## bash如何展开命令行*****************************************重点\n把命令行分成单个命令词  \n展开别名  \n展开大括号的声明（{}）  \n展开波浪符声明（~）  \n命令替换$()和``）  \n再次把命令行分成命令词  \n展开文件通配（*、?、[abc]等等）  \n准备I/0重导向（<、>）  \n运行命令  \n防止扩展  \n反斜线（\\）会使随后的字符按原意解释 \n\n$echoYourcost:\\$5.00\n\nYourcost:`$`5.00  \n加引号来防止扩展  \n单引号（’）防止所有扩展  \n`$`（美元符号）－变量扩展  \n`（反引号）－命令替换  \n\\（反斜线）－禁止单个字符扩展  \n!（叹号）－历史命令替换  \n***\n# Profile类\n按功能划分，存在两类：  \nprofile类和bashrc类  \nprofile类：为交互式登录的shell提供配置  \n全局：/etc/profile, /etc/profile.d/*.sh  \n个人：~/.bash_profile  \n功用：  \n(1) 用于定义环境变量  \n(2) 运行命令或脚本  \nBashrc类  \nbashrc类：为非交互式和交互式登录的shell提供配置  \n全局：/etc/bashrc  \n个人：~/.bashrc  \n功用：  \n(1) 定义命令别名和函数  \n(2) 定义本地变量  \n***  \n### locate命令\nlocate KEYWORD  \n有用的选项  \n>-i不区分大小写的搜索  \n>-n N只列举前N个匹配项目  \n>-r 使用正则表达式  \n示例  \n搜索名称或路径中带有“conf”的文件  \nlocate conf  \n使用Regex来搜索以“.conf”结尾的文件  \nlocate -r ‘\\.conf$’  \n\n# find*******************************************重点  \n查找条件  \n指搜索层级  \n-maxdepthlevel 最大搜索目录深度,指定目录为第1级  \n-mindepthlevel 最小搜索目录深度  \n先处理目录内的文件，再处理目录  \n-depth  \n***\n根据文件名和inode查找：  \n-name \"文件名称\"：支持使用glob  \n*, ?, [], [^]  \n-iname\"文件名称\"：不区分字母大小写  \n-inumn 按inode号查找  \n-samefilename 相同inode号的文件  \n-links n 链接数为n的文件  \n-regex“PATTERN”：以PATTERN匹配整个文件路径，而非文件名称  \n***  \n根据属主、属组查找：  \n-user USERNAME：查找属主为指定用户(UID)的文件  \n-group GRPNAME: 查找属组为指定组(GID)的文件  \n-uidUserID：查找属主为指定的UID号的文件  \n-gidGroupID：查找属组为指定的GID号的文件  \n-nouser：查找没有属主的文件  \n-nogroup：查找没有属组的文件  \n*** \n根据文件类型查找：  \n>-type TYPE:  \n•f: 普通文件  \n•d: 目录文件  \n•l: 符号链接文件  \n•s：套接字文件  \n•b: 块设备文件  \n•c: 字符设备文件  \n•p: 管道文件  \n空文件或目录\n-empty\nfind /app -type d -empty\n***\n### find示例\n备份配置文件，添加.orig这个扩展名  \nfind -name “*.conf” -exec cp {} {}.orig\\;  \n提示删除存在时间超过３天以上的joe的临时文件  \nfind/tmp-ctime+3-userjoe-okrm{}\\;  \n在主目录中寻找可被其它用户写入的文件  \nfind~-perm-002 -execchmodo-w{}\\;   \nfind /home –type d -ls  \n***  \n# Find笔记**************************************  \nlocate text.sh搜索文件  \n因为是从locate的数据库搜索文件的，速度快不影响服务器性能，适合搜索本来就在内存中的文件，而新建的文件不会马上搜索到，可以输入updatedb更新locate数据库  \nlocata +\"*通配符\"搜索文件  \nlocata -r \"\\.sh$\"搜索以.sh结尾的文件(支持正则表达式)    \nfind搜索是实时搜索，在硬盘上搜索，速度慢且影响服务器性能，而且没有权限的文件夹搜索不进去 ******************************************（面试常有）  \nfind （路径）   -name（iname） \"*text*\"搜索包含text的文件+i后忽略大小写  \nfind -name \"*.txt\"  查找以txt结尾的文件  \nfind -empty 搜索空文件或者空目录  \nfind / -size 10k 搜索9-10k的文件  \nfind / -size -10k  搜索0-10k的文件  \nfind / -size +10k  搜索大于10k的文件  \nfind / -size +5k -size 10k 搜索5-10K的文件  \nfind -name \"*.txt\" -exec（批量） rm {} \\; 查找后缀名为txt的文件并 批量 删除  \n\nchmod a+x 文件   给所有人加上此文件的执行权限  \nll -d 查询当前目录下的权限  **********************************  \n### compress\ncompress +文件【多个文件时压缩每个文件为单独的压缩文件】  压缩该文件，压缩后该文件消失，生成一个.z的压缩文件  \ncompress -c +文件 > 文件.gz压缩文件并显示过程 不会丢失源文件，利用重定向保留原文件   \nuncompress +文件【同解压】 等于 compress -d+文件  解压该文件，解压后该文件消失，生成不带.z的原文件 ******************************************************\n### gzip  \ngzip +文件【多个文件时压缩每个文件为单独的压缩文件】  压缩该文件，压缩后该文件消失，生成一个.gz的压缩文件  \nzcat -c +文件 > 文件.gz压缩文件并显示过程 不会丢失源文件，利用重定向保留原文件 \ngunzip +文件【同解压】 等于 gzip -d+文件  解压该文件，解压后该文件消失，生成不带.gz的原文件  ****************************************  \n### bzip2\nbzip2 +文件【多个文件时压缩每个文件为单独的压缩文件】  压缩该文件，压缩后该文件消失，生成一个.bz2的压缩文件\nbzip2 -k 压缩文件并保留原文件  \n不会丢失源文件，利用重定向保留原文件  \nbzip2 -d+文件 等于bunzip2  解压该文件，解压后该文件消失，生成不带.bz2的原文件  \nbzcat +文件  查看压缩文件而不执行解压   ***************************  \n### xz\nxz +文件【多个文件时压缩每个文件为单独的压缩文件】  压缩该文件，压缩后该文件消失，生成一个.xz的压缩文件  \nzx -k 压缩文件并保留原文件  \n不会丢失源文件，利用重定向保留原文件  \nzx -d+文件 等于unzx  解压该文件，解压后该文件消失，生成不带.zx的原文件  \nxzcat +文件 查看压缩文件而不执行解压  \n处理-开头的文件时前面加--  \n以上压缩只能压缩单个文件，而不能压缩文件夹  \n压缩比 xz > bzip2 > gzip > compress  \n### zip  \nzip +生成文件名 +要压缩的文件名 压缩文件  \nzip -r /backup/sysconfig /etc/sysconfig  加-r是压缩文件夹，将etc下的文件夹    sysconfig打包压缩生成sysconfig.zip文件放到backup文件夹  \nunzip sysconfig.zip 解压文件 +p可以保留权限  \n### tar  \ntar -cvf etc.tar etc  将整个etc文件夹打包保存为etc.tar ，其中后缀名tar要手动添加，只有打包而没有压缩文件  \ntar -rf etc.tar text 追加text文件到tar.  \ntar xvf etc.tar -C /data  解压文件到data文件夹  \n***\n例子  \n将data下的文件夹etc先打包再压缩的三种方法，压缩比 xz >bz2 >gz  \ntar zcvf etc.tar.gz  /data/etc   \ntar jcvf etc.tar.bz2  /data/etc   \ntar Jcvf etc.tar.xz  /data/etc   \ntar cvf etc.tar.xz  解压到当前目录  \ntar xf etc.tar.bz2   解压到当前目录  \nsplit -b 2M -d /data/bigfile.tar.xz  bigfile 把大文件bigfile.tar.xz切割为每2M一个的小文件，并以bigfile开头后面加数字，如bigfile1,bigfile2,bigfile3  \ncat bigfile* > bigfile.tar.xz 合并切割的这些文件  \n# 处理文本的工具sed  *************************重点  \nsed工具  \n用法：  \nsed[option]... 'script' inputfile...  \n常用选项：  \n-n不输出模式空间内容到屏幕，即不自动打印  \n-e多点编辑  \n-f /PATH/SCRIPT_FILE从指定文件中读取编辑脚本  \n-r支持使用扩展正则表达式  \n-i.bak备份文件并原处编辑  \nscript:  \n'地址命令'  \n地址定界：  \n(1) 不给地址：对全文进行处理  \n(2) 单地址：  \n.#: 指定的行，$：最后一行  \n/pattern/：被此处模式所能够匹配到的每一行  \n(3) 地址范围：  \n.#,#  \n.#,+#  \n/pat1/,/pat2/  \n.#,/pat1/  \n(4) ~：步进  \n### 编辑命令：  \nd删除模式空间匹配的行，并立即启用下一轮循环  \np打印当前模式空间内容，追加到默认输出之后  \na` [\\]`text在指定行后面追加文本，支持使用\\n实现多行追加  \ni`[\\]`text在行前面插入文本  \nc` [\\]`text替换行为单行或多行文本  \nw /path/file保存模式匹配的行至指定文件  \nr /path/file读取指定文件的文本至模式空间中匹配到的行后  \n=为模式空间中的行打印行号  \n!模式空间中匹配行取反处理  \n\n## SED笔记**************************************************重点重点重点 \nSED\n\n用法：  不加-i时仅仅是打印到屏幕显示，加-i可以修改文件，一般加-i.bak备份一个.bak文件  \nsed[option]... 'script' inputfile...  \n常用选项：  \n-n不输出模式空间内容到屏幕，即不自动打印  \n-e多点编辑  \n-f /PATH/SCRIPT_FILE从指定文件中读取编辑脚本  \n-r支持使用扩展正则表达式  \n-i.bak备份文件并原处编辑  \n编辑命令：  \nd删除模式空间匹配的行，并立即启用下一轮循环  \np打印当前模式空间内容，追加到默认输出之后  \na` [\\]`text在指定行后面追加文本，支持使用\\n实现多行追加  \n`i[\\]`text在行前面插入文本  \n`c [\\]`text替换行为单行或多行文本  \nw /path/file保存模式匹配的行至指定文件  \nr /path/file读取指定文件的文本至模式空间中匹配到的行后  \n=为模式空间中的行打印行号  \n!模式空间中匹配行取反处理  \n***\n例子   \nsed‘2p’ /etc/passwd  \nsed–n ‘2p’ /etc/passwd  显示第2行  \nsed–n ‘1,4p’ /etc/passwd  显示1-4行  \nsed–n ‘/root/p’ /etc/passwd  显示带有root的行  \nsed–n ‘2,/root/p’ /etc/passwd  从2行开始  \nsed-n ‘/^`$`/=’ file 显示空行行号  =代表行号   \nsed–n –e ‘/^$/p’ –e ‘/^$/=’ file  \nsed–n –r '/^#|^$/d' + file 删除该文件中带#注释和空白的行  \nsed‘/root/a\\superman’ /etc/passwd行后  \nsed‘/root/i\\superman’ /etc/passwd行前  \nsed‘/root/c\\superman’ /etc/passwd代替行  \ns///查找替换,支持使用其它分隔符，s@@@，s###  \n替换标记：  \ng行内全局替换  \np显示替换成功的行  \nw /PATH/FILE将替换成功的行保存至文件中  \nnl 可以显示行号  \n***\nsed -n '/^u/p'  /data/f1  打印出data下的f1文件中以u开头的行  \nsed -n '3,9'只显示3-9行  \nsed -n '/^ftp/,/^lib/' passwd 显示passwd文件中以ftp开头和以lib开头之间的行  \nsed -n '1~2p' 打印奇数行  \nsed -n '2~2p' 打印偶数行  \nsed -i '/^SELINUX=/cSELINUX=disabled' /etc/selinux/config  把config文件中的SELINUX=enforcing改为SELINUX=disabled  禁用selinux   \nsed -n 's/tmpfs/tempfilesystem/g' /etc/fstab 将文件fstab中的tmpfs替换为  tempfilesystem，并且只显示替换结果，s为查找替换，p为只显示替换的那一行  \nsed -r 's/[[:alpha:]]/\\u&/g' +文件 [[:alpha:]]意思为字母，u为大写，&表示搜索到的内容，用u&替换原内容，把所有的字母替换为大写  \nsed -r 's/[[:alpha:]]/\\l&/g' +文件 [[:alpha:]]意思为字母，l为小写，&表示搜索到的内容，用u&替换原内容，把所有的字母替换为小写  \nsed -r 's/^[^#]/#&' +文件 将文件中不是#开头的行加上#并显示，其中&代表被搜索出来的内容，等于用#&替换了原来的内容，加-i可以直接修改 .............................（重点）  \nsed -nr '/.*CMDLINE_LINUX.*/s#(.*)\"#\\1 net.ifnames=0\"#p' /etc/default/grub   在带有CMDLINE_LINUX的一行后加上net.ifnames=0  仅在7系统需要修改    ......................修改  \ns///查找替换,支持使用其它分隔符，s@@@，s###  \n替换标记：  \ng行内全局替换  \np显示替换成功的行  \nw /PATH/FILE将替换成功的行保存至文件中  \n***\n第三次博客：  \nTXT:10-08--10-14  \nPDF 6开始-PDF9  \n***","tags":["shell脚本"]},{"title":"Linux下各压缩工具的使用方法","url":"%2F2018%2F10%2F02%2FLinux%E4%B8%8B%E5%90%84%E5%8E%8B%E7%BC%A9%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F","content":"\n# 压缩工具\n### compress\n>compress +文件【多个文件时压缩每个文件为单独的压缩文件】  压缩该文件，压缩后该文件消失，生成一个.z的压缩文件  \ncompress -c +文件 > 文件.gz压缩文件并显示过程 不会丢失源文件，利用重定向保留原文件   \nuncompress +文件【同解压】 等于 compress -d+文件  解压该文件，解压后该文件消失，生成不带.z的原文件 \n### gzip  \n>gzip +文件【多个文件时压缩每个文件为单独的压缩文件】  压缩该文件，压缩后该文件消失，生成一个.gz的压缩文件  \nzcat -c +文件 > 文件.gz压缩文件并显示过程 不会丢失源文件，利用重定向保留原文件 \ngunzip +文件【同解压】 等于 gzip -d+文件  解压该文件，解压后该文件消失，生成不带.gz的原文件  \n### bzip2\n>bzip2 +文件【多个文件时压缩每个文件为单独的压缩文件】  压缩该文件，压缩后该文件消失，生成一个.bz2的压缩文件\nbzip2 -k 压缩文件并保留原文件  \n不会丢失源文件，利用重定向保留原文件  \nbzip2 -d+文件 等于bunzip2  解压该文件，解压后该文件消失，生成不带.bz2的原文件  \nbzcat +文件  查看压缩文件而不执行解压  \n### xz\n>xz +文件【多个文件时压缩每个文件为单独的压缩文件】  压缩该文件，压缩后该文件消失，生成一个.xz的压缩文件  \nzx -k 压缩文件并保留原文件  \n不会丢失源文件，利用重定向保留原文件  \nzx -d+文件 等于unzx  解压该文件，解压后该文件消失，生成不带.zx的原文件  \nxzcat +文件 查看压缩文件而不执行解压  \n处理-开头的文件时前面加--  \n以上压缩只能压缩单个文件，而不能压缩文件夹  \n压缩比 xz > bzip2 > gzip > compress  \n### zip  \nzip +生成文件名 +要压缩的文件名 压缩文件  \n```bash\nzip -r /backup/sysconfig /etc/sysconfig  加-r是压缩文件夹，将etc下的文件sysconfig打包压缩生成sysconfig.zip文件放到backup文件夹  \nunzip sysconfig.zip 解压文件 +p可以保留权限  \n```\n### tar  \n```bash\ntar -cvf etc.tar etc  将整个etc文件夹打包保存为etc.tar ，其中后缀名tar要手动添加，只有打包而没有压缩文件  \ntar -rf etc.tar text 追加text文件到tar.  \ntar xvf etc.tar -C /data  解压文件到data文件夹  \n```\n***\n例子  \n将data下的文件夹etc先打包再压缩的三种方法，压缩比 xz >bz2 >gz  \n```bash\ntar zcvf etc.tar.gz  /data/etc   \ntar jcvf etc.tar.bz2  /data/etc   \ntar Jcvf etc.tar.xz  /data/etc   \ntar cvf etc.tar.xz                #解压到当前目录  \ntar xf etc.tar.bz2               #解压到当前目录  \nsplit -b 2M -d /data/bigfile.tar.xz  bigfile #把大文件bigfile.tar.xz切割为每2M一个的小文件，并以bigfile开头后面加数字，如bigfile1,bigfile2,bigfile3  \ncat bigfile* > bigfile.tar.xz     #合并切割的这些文件 ","tags":["L·H"]},{"title":"SHELL脚本和Sed等工具的使用","url":"%2F2018%2F10%2F01%2FSHELL%E8%84%9A%E6%9C%AC%E5%92%8CSed%E7%AD%89%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%2F","content":"\n## SHELL脚本(重点 ) \n**创建shell脚本**  \n第一步：使用文本编辑器来创建文本文件  \n第一行必须包括shell声明序列：#!  \n>.#!/bin/bash  \n添加注释  \n注释以#开头  \n第二步：运行脚本  \n给予执行权限，在命令行上指定脚本的绝对或相对路径  \n直接运行解释器，将脚本作为解释器程序的参数运行  \n脚本规范  \n脚本代码开头约定  \n1、第一行一般为调用使用的语言  \n2、程序名，避免更改文件名为无法找到正确的文件  \n3、版本号  \n4、更改后的时间  \n5、作者相关信息  \n6、该程序的作用，及注意事项  \n7、最后是各版本的更新简要说明  \nshell脚本示例  \n```bash\n#!/bin/bash  \n#------------------------------------------    \n#Filename: hello.sh   \n#Revision: 1.1    \n#Date: 2011/06/01  \n#Author: luhao \n#Email: luhao2149@vip.qq.com  \n#Website: https://blog.csdn.net/weixin_43551152\n#Description: This is the first script  \n#------------------------------------------  \n#Copyright: 2011\n#License: GPL  \necho “hello world”  \n```\n**.vimrc文件在根目录下，修改：vim  .vimrc 文件**\n可以修改vim的脚本注释作者等信息\n***\n### 局部变量\n变量赋值：name=‘value’  \n可以使用引用value:  \n(1) 可以是直接字串; name=\"root\"  \n(2) 变量引用：name=\"$USER\" \n\n(3) 命令引用：name=`COMMAND` name=$(COMMAND)  \n变量引用：${name} $name  \n\"\"：弱引用，其中的变量引用会被替换为变量值  \n\n' '：强引用，其中的变量引用不会被替换为变量值，而保持原字符串  \n显示已定义的所有变量：set  \n删除变量：unset name  \n环境变量   \n变量声明、赋值：  \nexport name=VALUE  \ndeclare -x name=VALUE  \n变量引用：$name, ${name}  \n显示所有环境变量：  \nenv\n\nprintenv  \nexport  \ndeclare -x  \n删除变量：  \nunset name  \n退出状态  \n进程使用退出状态来报告成功或失败  \n0 代表成功，1－255代表失败  \n`$`? 变量保存最近的命令退出状态  \n例如：  \nping-c1-W1hostdown&>/dev/null  \necho$?  \n***\n###  算术运算\nbash中的算术运算:help let  \n+, -, *, /, %取模（取余）, **（乘方）  \n实现算术运算：  \n(1) let var=算术表达式  \n(2) var=$[算术表达式]  \n(3) var=$((算术表达式))  \n(4) var=$(expr arg1 arg2 arg3 ...)  \n(5) declare –ivar= 数值  \n(6) echo ‘算术表达式’ | bc  \n乘法符号有些场景中需要转义，如*  \nbash有内建的随机数生成器：$RANDOM（0-32767）  \necho $[$RANDOM%50] ：0-49之间随机数  \n增强型赋值：  \n+=, -=, *=, /=, %=  \nlet varOPERvalue  \n例如:let count+=3  \n自加3后自赋值  \n自增，自减：  \n例子：\n```bash   \nlet var+=1  \nlet var++  \nlet var-=1  \nlet var--  \nlet n=1+2  \necho $n  \n3  \nn=$（2+3）  \n2  \nexpr 3+4  错误  \nexpr 3 + 4  \n7  \nexpr为命令  3+4为参数之间要有空格************************************  \necho $[RANDOM%100+1] 取1-100之间的随机数 **  \nRANDOM为随机数，除以100得到的余数为0-99，+1后为1-100 *****  \necho $? 查询命令执行结果  \n```\n>& 与  交集\n| 或  并集  \n! 非    \n^ 异或 相同为0 不同为1  \n&& 短路与 两条命令，第一条为真，则执行第二天2条看真假，第一条为假的情况下直接不执行命令    \n|| 短路或 两条命令，第一条为假，则执行第二天2条看真假，第一条为真的情况下直接不执行命令  \n同或 相同为1  不同为0  \n\n**[ \"$str1\" !=\"$str2\" ] 判断两个字符串是否相同                    \nbash +x 加sh脚本可以看到脚本运行的过程，可以检查哪里出错  \nexport +定义的变量可使该变量在子进程中也生效  \nfind -name +文件名 查找文件或者安装包**  \n***\n### bash的数值测试\n```bash\n-v VAR  \n变量VAR是否设置  \n数值测试：  \n-gt是否大于  \n-ge是否大于等于  \n-eq是否等于  \n-ne是否不等于  \n-lt是否小于  \n-le是否小于等于  \nBash的文件属性测试  \n```\n### 文件大小测试：\n>-s FILE: 是否存在且非空  \n文件是否打开：  \n-t fd: fd文件描述符是否在某终端已经打开  \n-N FILE：文件自从上一次被读取之后是否被修改过  \n-O FILE：当前有效用户是否为文件属主  \n-G FILE：当前有效用户是否为文件属组  \nBash的文件测试  \n### 存在性测试\n>-a FILE：同-e  \n-e FILE: 文件存在性测试，存在为真，否则为假  \n存在性及类别测试  \n-b FILE：是否存在且为块设备文件  \n-c FILE：是否存在且为字符设备文件  \n-d FILE：是否存在且为目录文件  \n-f FILE：是否存在且为普通文件  \n-h FILE 或-L FILE：存在且为符号链接文件  \n-p FILE：是否存在且为命名管道文件  \n-S FILE：是否存在且为套接字文件  \n***\n**使用read命令来接受输入**  \n使用read来把输入值分配给一个或多个shell变量  \n-p指定要显示的提示  \n-s 静默输入，一般用于密码  \n-n N指定输入的字符长度N  \n-d‘字符’ 输入结束符  \n-t N TIMEOUT为N秒  \nread从标准输入中读取值，给每个单词分配一个变量  \n所有剩余单词都被分配给最后一个变量  \nread -p “Enter a filename:“ FILE  \n***\n## bash如何展开命令行\n把命令行分成单个命令词  \n展开别名  \n展开大括号的声明（{}）  \n展开波浪符声明（~）  \n命令替换$()和``）  \n再次把命令行分成命令词  \n展开文件通配（*、?、[abc]等等）  \n准备I/0重导向（<、>）  \n运行命令  \n防止扩展  \n反斜线（\\）会使随后的字符按原意解释 \n\n$echoYourcost:\\$5.00\n\nYourcost:`$`5.00  \n加引号来防止扩展  \n单引号（’）防止所有扩展  \n`$`（美元符号）－变量扩展  \n`（反引号）－命令替换  \n\\（反斜线）－禁止单个字符扩展  \n!（叹号）－历史命令替换  \n***\n# Profile类\n按功能划分，存在两类：  \nprofile类和bashrc类  \nprofile类：为交互式登录的shell提供配置  \n**全局：/etc/profile, /etc/profile.d/*.sh**  \n**个人：~/.bash_profile**  \n功用：  \n(1) 用于定义环境变量  \n(2) 运行命令或脚本  \nBashrc类  \nbashrc类：为非交互式和交互式登录的shell提供配置  \n全局：/etc/bashrc  \n个人：~/.bashrc  \n功用：  \n(1) 定义命令别名和函数  \n(2) 定义本地变量  \n***  \n### locate命令\nlocate KEYWORD  \n有用的选项  \n>-i不区分大小写的搜索  \n-n N只列举前N个匹配项目  \n-r 使用正则表达式  \n示例  \n搜索名称或路径中带有“conf”的文件  \nlocate conf  \n使用Regex来搜索以“.conf”结尾的文件  \nlocate -r ‘\\.conf$’  \n\n# find******************************练习  \n查找条件  \n指搜索层级  \n-maxdepthlevel 最大搜索目录深度,指定目录为第1级  \n-mindepthlevel 最小搜索目录深度  \n先处理目录内的文件，再处理目录  \n-depth  \n***\n根据文件名和inode查找：  \n>-name \"文件名称\"：支持使用glob  \n*, ?, [], [^]  \n-iname\"文件名称\"：不区分字母大小写  \n-inumn 按inode号查找  \n-samefilename 相同inode号的文件  \n-links n 链接数为n的文件  \n-regex“PATTERN”：以PATTERN匹配整个文件路径，而非文件名称  \n***  \n根据属主、属组查找：  \n\n>-user USERNAME：查找属主为指定用户(UID)的文件  \n-group GRPNAME: 查找属组为指定组(GID)的文件  \n-uidUserID：查找属主为指定的UID号的文件  \n-gidGroupID：查找属组为指定的GID号的文件  \n-nouser：查找没有属主的文件  \n-nogroup：查找没有属组的文件  \n*** \n根据文件类型查找：  \n>-type TYPE:  \n•f: 普通文件  \n•d: 目录文件  \n•l: 符号链接文件  \n•s：套接字文件  \n•b: 块设备文件  \n•c: 字符设备文件  \n•p: 管道文件  \n空文件或目录\n-empty\nfind /app -type d -empty\n### find示例\n备份配置文件，添加.orig这个扩展名  \n```bash\nfind -name “*.conf” -exec cp {} {}.orig\\;  \n```\n提示删除存在时间超过３天以上的joe的临时文件  \n```bash\nfind/tmp-ctime+3-userjoe-okrm{}\\;  \n```\n在主目录中寻找可被其它用户写入的文件  \n```bash\nfind ~-perm-002 -execchmodo-w{}\\;   \nfind /home –type d -ls  \n```\nlocate text.sh搜索文件  \n因为是从locate的数据库搜索文件的，速度快不影响服务器性能，适合搜索本来就在内存中的文件，而新建的文件不会马上搜索到，可以输入updatedb更新locate数据库  \nlocata +\"*通配符\"搜索文件  \nlocata -r \"\\.sh$\"搜索以.sh结尾的文件(支持正则表达式)    \n**find搜索是实时搜索，在硬盘上搜索，速度慢且影响服务器性能，而且没有权限的文件夹搜索不进去 ***************************（面试常有）**  \nfind （路径）   -name（iname） \"*text*\"搜索包含text的文件+i后忽略大小写**  \n例子\n```bash\nfind -name \"*.txt\"  查找以txt结尾的文件  \nfind -empty 搜索空文件或者空目录  \nfind / -size 10k 搜索9-10k的文件  \nfind / -size -10k  搜索0-10k的文件  \nfind / -size +10k  搜索大于10k的文件  \nfind / -size +5k -size 10k 搜索5-10K的文件  \nfind -name \"*.txt\" -exec（批量） rm {} \\; 查找后缀名为txt的文件并 批量 删除  \n```\nchmod a+x 文件   给所有人加上此文件的执行权限  \nll -d 查询当前目录下的权限  \n# 处理文本的工具sed  ********重点  \nsed工具  \n用法：  \n```bash\nsed [option]... 'script' inputfile...  \n常用选项：  \n-n不输出模式空间内容到屏幕，即不自动打印  \n-e多点编辑  \n-f /PATH/SCRIPT_FILE从指定文件中读取编辑脚本  \n-r支持使用扩展正则表达式  \n-i.bak备份文件并原处编辑  \n```\nscript:  \n'地址命令'  \n地址定界：  \n(1) 不给地址：对全文进行处理  \n(2) 单地址：  \n.#: 指定的行，$：最后一行  \n/pattern/：被此处模式所能够匹配到的每一行  \n(3) 地址范围：  \n.#,#  \n.#,+#  \n/pat1/,/pat2/  \n.#,/pat1/  \n(4) ~：步进  \n### 编辑命令：  \nd删除模式空间匹配的行，并立即启用下一轮循环  \np打印当前模式空间内容，追加到默认输出之后  \na` [\\]`text在指定行后面追加文本，支持使用\\n实现多行追加  \ni`[\\]`text在行前面插入文本  \nc` [\\]`text替换行为单行或多行文本  \nw /path/file保存模式匹配的行至指定文件  \nr /path/file读取指定文件的文本至模式空间中匹配到的行后  \n=为模式空间中的行打印行号  \n!模式空间中匹配行取反处理  \n\n## SED笔记*******************练习\nSED\n\n用法：  不加-i时仅仅是打印到屏幕显示，加-i可以修改文件，一般加-i.bak备份一个.bak文件  \n```bash\nsed[option]... 'script' inputfile...  \n常用选项：  \n-n不输出模式空间内容到屏幕，即不自动打印  \n-e多点编辑  \n-f /PATH/SCRIPT_FILE从指定文件中读取编辑脚本  \n-r支持使用扩展正则表达式  \n-i.bak备份文件并原处编辑  \n编辑命令：  \nd删除模式空间匹配的行，并立即启用下一轮循环  \np打印当前模式空间内容，追加到默认输出之后  \na` [\\]`text在指定行后面追加文本，支持使用\\n实现多行追加  \n`i[\\]`text在行前面插入文本  \n`c [\\]`text替换行为单行或多行文本  \nw /path/file保存模式匹配的行至指定文件  \nr /path/file读取指定文件的文本至模式空间中匹配到的行后  \n=为模式空间中的行打印行号  \n!模式空间中匹配行取反处理  \n```\n***\n例子   \n```bash\nsed ‘2p’ /etc/passwd  \nsed –n ‘2p’ /etc/passwd  显示第2行  \nsed –n ‘1,4p’ /etc/passwd  显示1-4行  \nsed –n ‘/root/p’ /etc/passwd  显示带有root的行  \nsed –n ‘2,/root/p’ /etc/passwd  从2行开始  \nsed -n ‘/^`$`/=’ file 显示空行行号  =代表行号   \nsed –n –e ‘/^$/p’ –e ‘/^$/=’ file  \nsed –n –r '/^#|^$/d' + file 删除该文件中带#注释和空白的行  \nsed ‘/root/a\\superman’ /etc/passwd行后  \nsed ‘/root/i\\superman’ /etc/passwd行前  \nsed ‘/root/c\\superman’ /etc/passwd代替行  \ns///查找替换,支持使用其它分隔符，s@@@，s###  \n```\n**替换标记：  \ng行内全局替换  \np显示替换成功的行  \nw /PATH/FILE将替换成功的行保存至文件中  \nnl 可以显示行号**  \n***\n实例\n```bash\nsed -n '/^u/p'  /data/f1  打印出data下的f1文件中以u开头的行  \nsed -n '3,9'只显示3-9行  \nsed -n '/^ftp/,/^lib/' passwd 显示passwd文件中以ftp开头和以lib开头之间的行  \nsed -n '1~2p' 打印奇数行  \nsed -n '2~2p' 打印偶数行  \nsed -i '/^SELINUX=/cSELINUX=disabled' /etc/selinux/config  把config文件中的SELINUX=enforcing改为SELINUX=disabled  禁用selinux   \nsed -n 's/tmpfs/tempfilesystem/g' /etc/fstab 将文件fstab中的tmpfs替换为  tempfilesystem，并且只显示替换结果，s为查找替换，p为只显示替换的那一行  \nsed -r 's/[[:alpha:]]/\\u&/g' +文件 [[:alpha:]]意思为字母，u为大写，&表示搜索到的内容，用u&替换原内容，把所有的字母替换为大写  \nsed -r 's/[[:alpha:]]/\\l&/g' +文件 [[:alpha:]]意思为字母，l为小写，&表示搜索到的内容，用u&替换原内容，把所有的字母替换为小写  \nsed -r 's/^[^#]/#&' +文件 将文件中不是#开头的行加上#并显示，其中&代表被搜索出来的内容，等于用#&替换了原来的内容，加-i可以直接修改 .............................（重点）  \nsed -nr '/.*CMDLINE_LINUX.*/s#(.*)\"#\\1 net.ifnames=0\"#p' /etc/default/grub   在带有CMDLINE_LINUX的一行后加上net.ifnames=0  仅在7系统需要修改    ......................修改  \ns///查找替换,支持使用其它分隔符，s@@@，s###  \n```\n替换标记：  \ng行内全局替换  \np显示替换成功的行  \nw /PATH/FILE将替换成功的行保存至文件中  \n","tags":["L·H"]},{"title":"文本处理及正则表达式","url":"%2F2018%2F09%2F30%2F%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%8F%8A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F","content":"\n# 文本处理及正则表达式\n###   文件查看\n文件查看命令：  \ncat，tac，rev\ncat [OPTION]... [FILE]...  \n```bash\ncat\n-E：显示行结束符$  \n-n：对显示出的每一行进行编号  \n-A：显示所有控制符  \n-b：非空行编号  \n-s：压缩连续的空行成一行  \n```\ntac  与cat相反\nrev  \n文件查看  \nmore: 分页查看文件  \n```bash\nmore [OPTIONS...] FILE...  \n-d: 显示翻页及退出提示  \nless：一页一页地查看文件或STDIN输出  \n```\n查看时有用的命令包括：  \n/文本搜索文本  \nn/N跳到下一个或上一个匹配  \nless命令是man命令使用的分页器  \n###  显示文本前或后行内容*******************************(重点)\nhead [OPTION]... [FILE]...  \n```bash\nhead\n-c #: 指定获取前#字节  \n-n #: 指定获取前#行  \n-#：指定行数  \ntail [OPTION]... [FILE]...  \n-c #: 指定获取后#字节  \n-n #: 指定获取后#行  \n-#：同上  \n-f: 跟踪显示文件fd新追加的内容,常用日志监控  \n相当于--follow=descriptor  \n-F: 跟踪文件名，相当于--follow=name --retry  \ntailf类似tail –f，当文件不增长时并不访问文件  \n```\n### 按列抽取文本cut和合并文件paste*********************CUT  \ncut [OPTION]... [FILE]...  \n```bash\ncut\n-d DELIMITER: 指明分隔符，默认tab  \n-f FILEDS:  \n#: 第#个字段  \n#,#[,#]：离散的多个字段，例如1,3,6  \n#-#：连续的多个字段, 例如1-6  \n```\n混合使用：1-3,7  \n-c按字符切割  \n--output-delimiter=STRING指定输出分隔符  \ncut和paste  \n显示文件或STDIN数据的指定列  \n```bash\ncut -d:-f1 /etc/passwd  \ncat /etc/passwd|cut -d: -f7  \ncut -c2-5/usr/share/dict/words  \n```\npaste 合并两个文件同行号的列到一行  \n```bash\npaste [OPTION]... [FILE]...  \n-d 分隔符：指定分隔符，默认用TAB  \n-s : 所有行合成一行显示  \n示例：  \npaste f1 f2  \npaste -s f1 f2\n```\n### 收集文本统计数据wc*****************************************WC  \n计数单词总数、行总数、字节总数和字符总数  \n可以对文件或STDIN中的数据运行  \nwcstory.txt  \n392371901story.txt  \n行数字数字节数  \n常用选项  \n```bash\nwc\n-l    只计数行数  \n-w    只计数单词总数  \n-c    只计数字节总数  \n-m    只计数字符总数  \n-L    显示文件中最长行的长度  \n```\n## 文本排序sort  \n把整理过的文本显示在STDOUT，不改变原始文件  \nsort[options]file(s)\n常用选项  \n```bash\nsort\n-r执行反方向（由上至下）整理\n-R随机排序  \n-n执行按数字大小整理  \n-f选项忽略（fold）字符串中的字符大小写  \n-u选项（独特，unique）删除输出中的重复行  \n-t c选项使用c做为字段界定符  \n-k X选项按照使用c字符分隔的X列来整理能够使用多次  \n```\n## uniq\nuniq命令：从输入中删除前后相接的重复的行  \nuniq[OPTION]... [FILE]...  \n```bash\nuniq\n-c: 显示每行重复出现的次数  \n-d: 仅显示重复过的行  \n-u: 仅显示不曾重复的行  \n注：连续且完全相同方为重复  \n常和sort 命令一起配合使用：  \nsort userlist.txt | uniq -c  \n```\n## 比较文件\n比较两个文件之间的区别  \n```bash\ndifffoo.conffoo2.conf  \n5c5 \n< use_widgets=no\n>use_widgets=yes          #注明第5行有区别（改变）\n```\n#  取出IP地址的几种方法**********（重点）\n```bash\nifconfig | sed -r '2!d;s/.*inet (addr:)?//;s/ .*//'   #6和7通用的取出IP地址    \nifconfig eth0 | head -2|tail -1| tr -dc '[0-9]. ' |tr -s ' ' |cut -d\" \" -f2   #centos6系统上  \nifconfig eth0|sed -n '2p'|sed 's@.*inet @@'|sed 's@ netmask.$@@' #提取出7上的IP地址，其中@@为分隔符  \nifconfig ens33|sed -nr '2s/.*t (.*) net.*/\\1/gp' #扩展的正则表达式取出IP，（）为分组，只有一个括号，所以后面写1  \nifconfig ens33|sed -nr '2s/（.*t) (.*)( net.*)/\\2/gp' #扩展的正则表达式取出IP，（）为分组，有三个括号，所以后面写2留第二个  \nifconfig | sed -nr \"s/.inet (.*) netmask.*/\\1/p\" | head -n 1   #取出7的IP  \nifconfig | sed -nr \"s/.inet (.*) netmask.*/\\1/p\" #取出7的三个网卡IP  \n```\n# 查询系统信息  *****************重点  \n```bash\n#RED is content color  \nRED=\"\\033[1;31m\"  \nCOLOREND=\"\\033[0m\"  \necho -e \"OS version is $RED`cat /etc/centos-release`$COLOREND\"  #显示系统版本 \necho -e \"kernel version $RED`uname -r`$COLOREND\"    #显示内核版本 \necho -e \"The cpu type is $RED`lscpu |egrep -i 'model name'|tr -s ' '|cut -d: -f2`$COLOREND\"        #显示CPU型号 \necho -e \"The memory is $RED`free -h|egrep Mem|tr -s ' ' ':' |cut -d: -f2`$COLOREND\"           #取出内存大小  \necho -e \"The max disk used is $RED`df |grep  /dev/sd|tr -s \" \" \":\"|cut -d: -f5|sort -nr|head -1`$COLOREND\"      #取出最大磁盘利用率\necho -e \"The hostname is $RED$(hostname)$COLOREND\"    #取出hostname \necho -e \"The ipaddr is $RED`ifconfig|head -2|tail -1|tr -s \" \" \":\"|cut -d: -f3`$COLOREND\"      #取出IP地址\nunset RED COLOREND        #不使用颜色\n```\n# Linux文本处理三剑客\n>grep：文本过滤(模式：pattern)工具  \ngrep, egrep, fgrep（不支持正则表达式搜索）  \nsed：stream editor，文本编辑工具  \nawk：Linux上的实现gawk，文本报告生成器  \n## grep**************************************(重点)\ngrep: Global search REgularexpression and Print out the line  \n作用：文本搜索工具，根据用户指定的“模式”对目标文本逐行进行匹配检查；打印匹配到的行  \n模式：由正则表达式字符及文本字符所编写的过滤条件  \n```bash\ngrep [OPTIONS] PATTERN [FILE...]  \ngrep root /etc/passwd  \ngrep \"$USER\" /etc/passwd  \ngrep '$USER' /etc/passwd  \ngrep `whoami` /etc/passwd  \n```\n**grep命令选项**  \n```bash\ngrep\n--color=auto: 对匹配到的文本着色显示  \n-v: 显示不被pattern匹配到的行  \n-i: 忽略字符大小写  \n-n：显示匹配的行号  \n-c: 统计匹配的行数  \n-o: 仅显示匹配到的字符串  \n-q: 静默模式，不输出任何信息  \n-A #: after, 后#行  \n-B #: before, 前#行  \n-C #：context, 前后各#行  \n-e：实现多个选项间的逻辑or关系  \ngrep –e ‘cat ’ -e ‘dog’ file  \n-w：匹配整个单词  \n-E：使用ERE  \n-F：相当于fgrep，不支持正则表达式  \n-ffile: 根据模式文件处理  \n```\n# 正则表达式*************************重点\nREGEXP：Regular Expressions，由一类特殊字符及文本字符所编写的模式，其中有些字符（元字符）不表示字符字面意义，而表示控制或通配的功能  \n程序支持：grep,sed,awk,vim, less,nginx,varnish等  \n分两类：  \n基本正则表达式：BRE  \n扩展正则表达式：ERE  \ngrep -E, egrep  \n正则表达式引擎：  \n采用不同算法，检查处理正则表达式的软件模块  \nPCRE（Perl Compatible Regular Expressions）  \n元字符分类：字符匹配、匹配次数、位置锚定、分组  \nman 7 regex    \n### 基本正则表达式元字符  \n字符匹配:  \n>. 匹配任意单个字符  \n[] 匹配指定范围内的任意单个字符，示例：[wang] [0-9] [a-z] [a-zA-Z]  \n[^] 匹配指定范围外的任意单个字符  \n[:alnum:] 字母和数字  \n[:alpha:] 代表任何英文大小写字符，亦即A-Z, a-z  \n[:lower:] 小写字母[:upper:] 大写字母  \n[:blank:] 空白字符（空格和制表符）  \n[:space:]水平和垂直的空白字符（比[:blank:]包含的范围广）  \n[:cntrl:] 不可打印的控制字符（退格、删除、警铃...）  \n[:digit:] 十进制数字[:xdigit:]十六进制数字  \n[:graph:] 可打印的非空白字符  \n[:print:] 可打印字符  \n[:punct:] 标点符号  \n### 通配符是通配的文件名  \n正则表达式是配的字符串，文件的内容  \n【wang】 匹配这四个字符其中的一个  \n```bash\ngrep \"[123]\" /etc/passwd     #查询passwd文件夹里包含123中一个数字的文件  \ngrep -v \"[123]\" /etc/passwd  #查询passwd文件夹里不包含123中一个数字的文件  \ngrep \"[^123]\" /etc/passwd   #查询passwd文件夹里除了123中一个数字的文件  \n```\n匹配次数：用在要指定次数的字符后面，用于指定前面的字符要出现的次数  \n```\n* 匹配前面的字符任意次，包括0次  \n贪婪模式：尽可能长的匹配  \n.*任意长度的任意字符  \n\\?匹配其前面的字符0或1次  \n\\+匹配其前面的字符至少1次  \n\\{n\\}匹配前面的字符n次  \n\\{m,n\\}匹配前面的字符至少m次，至多n次  \n\\{,n\\}匹配前面的字符至多n次  \n\\{n,\\}匹配前面的字符至少n次   \n```\n### 位置锚定：定位出现的位置  \n^ 行首锚定，用于模式的最左侧 grep \"^bash\" /etc/passwd  \n$ 行尾锚定，用于模式的最右侧 grep \"bash$\" /etc/passwd  \n^PATTERN$ 用于模式匹配整行  \n^$ 空行  \n^[[:space:]]*$ 空白行  \n\\< 或\\b词首锚定，用于单词模式的左侧(单词不能包含数字、_、其他字母开头)  \n\\> 或\\b词尾锚定，用于单词模式的右侧  \n\\<PATTERN\\>匹配整个单词***************************************************  \n### 正则表达式\n分组：\\(\\) 将一个或多个字符捆绑在一起，当作一个整体处理，如：\\(root\\)\\+  \n分组括号中的模式匹配到的内容会被正则表达式引擎记录于内部的变量中，这些变量的命名方式为: \\1, \\2, \\3, ...  \n\\1表示从左侧起第一个左括号以及与之匹配右括号之间的模式所匹配到的字符  \n示例：\\(string1\\+\\(string2\\)*\\)  \n\\1 ：string1\\+\\(string2\\)*  \n\\2 ：string2  \n后向引用：引用前面的分组括号中的模式所匹配字符，而非模式本身  \n或者：\\|  \n示例：a\\|b: a或b C\\|cat: C或cat \\(C\\|c\\)at:Cat或cat  \n元字符  \n>^ 行首    \n`$`行尾  \n.任意单一字符    \n[][]内任意单一字符    \n[^]除[]内任意单一字符   \n**前面字符重复不确定次数    \n\\+\\+前面字符重复一次以上不确定次数  \n\\?？前面字符重复0或1次  \n\\转义符  \n.*任意长度字符  \n\\{n\\}前面字符重复n次  \n\\{n,\\}前面字符重复n次以上  \n\\{m,n\\}前面字符重复m次和n次之间  \n[:alnum:]字母和数字  \n[:alpha:]代表任何英文大小写字符，亦即A-Z, a-z  \n[:lower:]小写字母  \n[:upper:]大写字母  \n[:blank:]水平空白字符（空格和制表符）  \n[:space:]所有水平和垂直的空白字符（比[:blank:]包含的范围广）  \n[:cntrl:]不可打印的控制字符（退格、删除、警铃...）  \n[:digit:]十进制数字  \n[:graph:]可打印的非空白字符  \n[:print:]可打印字符  \n[:punct:]标点符号  \n[:xdigit:]十六进制数字    \n## egrep及扩展的正则表达式\negrep= grep -E  \negrep[OPTIONS] PATTERN [FILE...]  \n扩展正则表达式的元字符：  \n字符匹配：\n  \n>. 任意单个字符  \n[] 指定范围的字符  \n[^] 不在指定范围的字符  \n次数匹配：  \n*匹配前面字符任意次  \n?0或1次  \n+1次或多次  \n{m}匹配m次  \n{m,n}至少m，至多n次  \n位置锚定：  \n^行首   \n$行尾  \n\\<, \\b语首  \n\\>, \\b语尾  \n分组：()  \n后向引用：\\1, \\2, ...  \n或者：  \na|ba或b  \nC|catC或cat  \n(C|c)atCat或cat  \n\n# vim简介*****************************重点  \n见PDF6中第32，68，69页图片   \nvi: Visual Interface，文本编辑器  \n文本：ASCII, Unicode  \n文本编辑种类：  \n**行编辑器: sed  \n全屏编辑器：nano, vi  \nvim-Vi Improved**  \n其他编辑器：  \n**gedit一个简单的图形编辑器  \ngvim一个Vim编辑器的图形版本**  \n### 打开文件\n```bash\nvim [OPTION]... FILE...  \n+#打开文件后，让光标处于第#行的行首，+默认行尾  \n+/PATTERN打开文件后，直接让光标处于第一个被PATTERN匹配到的行的行首  \n–b file 二进制方式打开文件  \n–d file1 file2… 比较多个文件  \n-m file 只读打开文件  \nex file 或vim –e 直接进入ex模式  \n如果该文件存在，文件被打开并显示内容  \n如果该文件不存在，当编辑后第一次存盘时创建它  \n模式转换  \n命令模式--> 插入模式  \niinsert, 在光标所在处输入  \nI在当前光标所在行的行首输入  \naappend, 在光标所在处后面输入  \nA在当前光标所在行的行尾输入  \no在当前光标所在行的下方打开一个新行  \nO在当前光标所在行的上方打开一个新行  \n```\n## **VIM模式的切换**\n插入模式--------> 命令模式  \nESC  \n命令模式--------> 扩展命令模式  \n:  \n扩展命令模式--------> 命令模式  \nESC,enter  \n************************************************************\n扩展命令模式：  \n>:q退出  \n:q!强制退出，丢弃做出的修改  \n:wq保存退出  \n:x保存退出  \n命令模式  \n**ZZ保存退出  \nZQ不保存退出**  \n命令模式光标跳转  \n字符间跳转：  \nh: 左l: 右j: 下k: 上  \n.#COMMAND：跳转由#指定的个数的字符******************  \n### 单词间跳转：\n>w：下一个单词的词首  \ne：当前或下一单词的词尾  \nb：当前或前一个单词的词首  \n。#COMMAND：由#指定一次跳转的单词数  \n当前页跳转：  \nH：页首M：页中间行L:页底  \nzt：将光标所在当前行移到屏幕顶端  \nzz：将光标所在当前行移到屏幕中间  \nzb：将光标所在当前行移到屏幕底端  \n行首行尾跳转：  \n^: 跳转至行首的第一个非空白字符  \n0: 跳转至行首  \n`$`: 跳转至行尾  \n行间移动：  \n.#G、扩展命令模式下：# 跳转至由#指定行  \nG：最后一行  \n1G, gg: 第一行  \n句间移动：  \n)：下一句(：上一句  \n段落间移动：  \n}:下一段{：上一段  \n命令模式翻屏操作  \n**Ctrl+f: 向文件尾部翻一屏    \nCtrl+b: 向文件首部翻一屏  \nCtrl+d: 向文件尾部翻半屏  \nCtrl+u：向文件首部翻半屏**  \n### 命令模式操作**********************************************重点  \n```bash\n删除命令：  \nd: 删除命令，可结合光标跳转字符，实现范围删除  \nd`$`: 删除到行尾  \nd^:删除到非空行首  \nd0:删除到行首  \ndw:  \nde:  \ndb:  \n.#COMMAND  \ndd: 删除光标所在的行  \n.#dd：多行删除  \nD：从当前光标位置一直删除到行尾，等同于d$  \n复制命令(y, yank)：  \ny: 复制，行为相似于d命令\ny$  \ny0  \ny^  \nye  \nyw  \nyb  \n.#COMMAND  \nyy：复制行  \n.#yy: 复制多行  \nY: 复制整行\n```\n### 命令模式\n```bash\ndi\" 光标在”“之间，则删除”“之间的内容  \nyi( 光标在()之间，则复制()之间的内容  \nvi[ 光标在[]之间，则选中[]之间的内容  \ndtx删除字符直到遇见光标之后的第一个x 字符  \nytx复制字符直到遇见光标之后的第一个x 字符  \n扩展命令模式：地址定界********************按ESC进入命令模式，再按：进入扩展命令模式  \n```\n###地址定界\n>:start_pos,end_pos  \n`# 具体第#行，例如2表示第2行  \n`#,# 从左侧#表示起始行，到右侧#表示结尾行  \n`#,+# 从左侧#表示的起始行，加上右侧#表示的行数  \n：2,+3 表示2到5行  \n. 当前行  \n`$` 最后一行  \n.,`$`-1 当前行到倒数第二行  \n% 全文, 相当于1,$  \n/pat1/,/pat2/  \n从第一次被pat1模式匹配到的行开始，一直到第一次被pat2匹配到的行结束  \n#,/pat/  \n/pat/,$  \n使用方式：后跟一个编辑命令  \nd  \ny  \nw file: 将范围内的行另存至指定文件中  \nr file：在指定位置插入指定文件中的所有内容  \n/PATTERN：从当前光标所在处向文件尾部查找  \n?PATTERN：从当前光标所在处向文件首部查找  \nn：与命令同方向  \nN：与命令反方向  \n***\n## s: 在扩展模式下完成查找替换操作******************重点\n格式：s/要查找的内容/替换为的内容/修饰符  \n要查找的内容：可使用模式  \n替换为的内容：不能使用模式，但可以使用\\1, \\2, ...等后向引用符号；还可以使用“&”引用前面查找时查找到的整个内容  \n修饰符： \n```bash\ns/要查找的内容/替换为的内容/修饰符 \ni: 忽略大小写  \ng: 全局替换；默认情况下，每一行只替换第一次出现  \ngc:全局替换，每次替换前询问  \n查找替换中的分隔符/可替换为其它字符，例如  \ns@/etc@/var@g  \ns#/boot#/#i  \n```\n命令模式：撤消更改  \nu撤销最近的更改  \n#u撤销之前多次更改  \nU撤消光标落在这行后所有此行的更改  \n按Ctrl-r重做最后的“撤消”更改  \n. 重复前一个操作  \nn.重复前一个操作n次  \n多文件模式  \n```bash\nvim FILE1 FILE2 FILE3 ...  \n:next 下一个  \n:prev前一个  \n:first 第一个  \n:last 最后一个  \n:wall 保存所有  \n:qall退出所有  \n:wqall  \n```\n### 定制vim的工作特性\n配置文件：永久有效  \n**全局：/etc/vimrc***********************  \n个人：~/.vimrc**  \n扩展模式：当前vim进程有效  \n**(1) 行号  \n显示：set number, 简写为set nu  \n取消显示：set nonumber, 简写为set nonu**  \n(2) 忽略字符的大小写  \n启用：set ic  \n不忽略：set noic  \n(3) 自动缩进  \n启用：set ai  \n禁用：set noai  \n(4) 智能缩进  \n启用：smartindent简写set si  \n禁用：set nosi  \n(5) 高亮搜索  \n启用：set hlsearch  \n禁用：set nohlsearch  \n(6) 语法高亮  \n启用：syntax on  \n禁用：syntax off  \n(7) 显示Tab和换行符^I 和$显示  \n启用：set list  \n禁用：set nolist  \n(8) 文件格式  \n启用windows格式：set fileformat=dos  \n启用unix格式：set fileformat=unix  \n简写：set ff=dos|unix  \n(9) 设置文本宽度  \nset textwidth=65 (vimonly)  \nset wrapmargin=15  \n(10) 设置光标所在行的标识线  \n启用：set cursorline，简写cul  \n禁用：set no cursorline  \n(11) 复制保留格式  \n启用：set paste  \n禁用：set nopaste  \n***  ","tags":["L·H"]},{"title":"用户、组和权限","url":"%2F2018%2F09%2F29%2F%E7%94%A8%E6%88%B7%E3%80%81%E7%BB%84%E5%92%8C%E6%9D%83%E9%99%90%2F","content":"\n# 用户、组和权限  \n\n## 用户和组的配置文件  \nLinux用户和组的主要配置文件：  \n>/etc/passwd：用户及其属性信息(名称、UID、主组ID等）  \n/etc/group：组及其属性信息  \n/etc/shadow：用户密码及其相关属性  \n/etc/gshadow：组密码及其相关属性  \n***\npasswd文件格式  \n>login name：登录用名（luhao）  \npasswd：密码(x)  \nUID：用户身份编号(1000)  \nGID：登录默认所在组编号(1000)  \nGECOS：用户全名或注释  \nhome directory：用户主目录(/home/luhao)  \nshell：用户默认使用shell (/bin/bash)  \n***\n### shadow文件格式  \n**登录用名**  \n用户密码:一般用sha512加密  \n从1970年1月1日起到密码最近一次被更改的时间  \n密码再过几天可以被变更（0表示随时可被变更）  \n密码再过几天必须被变更（99999表示永不过期）  \n密码过期前几天系统提醒用户（默认为一周）  \n密码过期几天后帐号会被锁定  \n从1970年1月1日算起，多少天后帐号失效  \n***\n### 用户创建：useradd  \nuseradd[options] LOGIN  \n```\nuseradd\n-u UID  \n-o 配合-u 选项，不检查UID的唯一性  \n-g GID：指明用户所属基本组，可为组名，也可以GID  \n-c 'COMMENT'：用户的注释信息  \n-d HOME_DIR: 以指定的路径(不存在)为家目录  \n-s SHELL: 指明用户的默认shell程序，可用列表在/etc/shells文件中  \n-G GROUP1[,GROUP2,...]：为用户指明附加组，组须事先存在  \n-N 不创建私用组做主组，使用users组做主组  \n-r: 创建系统用户CentOS 6: ID<500，CentOS 7: ID<1000  \n-m 创建家目录，用于系统用户  \n-M 不创建家目录，用于非系统用户  \n```\n***\n新建用户的相关文件和命令  \n>/etc/default/useradd  \n/etc/skel/*  \n/etc/login.defs  \nnewusers passwd格式文件批量创建用户  \nchpasswd 批量修改用户口令  \n***\n## 用户属性修改  \nusermod[OPTION] login  \n```\nusermod\n-u      UID: 新UID  \n-g      GID: 新主组  \n-G      GROUP1[,GROUP2,...[,GROUPN]]]：新附加组，原来的附加组将会被覆盖；若保留原有，则要同时使用-a选项  \n-s      SHELL：新的默认SHELL  \n-c      COMMENT：新的注释信息  \n-d      HOME: 新家目录不会自动创建；若要创建新家目录并移动原家数据，同时使用-m选项  \n-l      login_name: 新的名字；  \n-L:     lock指定用户,在/etc/shadow 密码栏的增加!  \n-U:     unlock指定用户,将/etc/shadow 密码栏的! 拿掉  \n-e     YYYY-MM-DD: 指明用户账号过期日期  \n-f     INACTIVE: 设定非活动期限  \nuserdel[OPTION]... login      删除用户  \n-r        删除用户家目录\n```\n***\n查看用户相关的ID信息  \n```\nid [OPTION]... [USER]  \n-u: 显示UID  \n-g: 显示GID  \n-G: 显示用户所属的组的ID  \n-n: 显示名称，需配合ugG使用  \n```\n切换用户或以其他用户身份执行命令  \nsu[options...] [-] [user [args...]]  \n切换用户的方式：\n  \n>suUserName：非登录式切换，即不会读取目标用户的配置文件，不改变当前工作目录  \nsu-UserName：登录式切换，会读取目标用户的配置文件，切换至家目录，完全切换  \nroot su至其他用户无须密码；非root用户切换时需要密码  \n换个身份执行命令：  \nsu[-] UserName-c 'COMMAND'  \n选项：-l --login  \nsu-l UserName相当于su-UserName  \n***\n## 设置密码  \npasswd[OPTIONS] UserName: 修改指定用户的密码  \n常用选项：  \n```\npasswd\n-d：删除指定用户密码  \n-l：锁定指定用户  \n-u：解锁指定用户  \n-e：强制用户下次登录修改密码  \n-f：强制操作  \n-n mindays：指定最短使用期限  \n-x maxdays：最大使用期限  \n-w warndays：提前多少天开始警告  \n-iinactivedays：非活动期限  \n--stdin：从标准输入接收用户密码  \necho 'PASSWORD' | passwd--stdinUSERNAME  \n```\n**修改用户密码策略**\n```\nchage[OPTION]... LOGIN   \n-d LAST_DAY  \n-E --expiredateEXPIRE_DATE  \n-I --inactive INACTIVE  \n-m --mindaysMIN_DAYS  \n-M --maxdaysMAX_DAYS  \n-W --warndaysWARN_DAYS  \n–l 显示密码策略  \n```\n示例：  \n```\nchage-d 0 tom      #让tom下一次登录强制重设密码  \nchage-m 0 –M 42 –W 14 –I 7 tom  让tom多少天之后重设密码\nchage-E 2016-09-10 tom            #让tom在2016-09-10重设密码\n```\n**创建组**  \ngroupadd[OPTION]... group_name  \n```\ngroupadd\n-g GID: 指明GID号；[GID_MIN, GID_MAX]   \n-r: 创建系统组  \n```\n**系统组ID范围**\nCentOS 6: ID<500  \nCentOS 7: ID<1000  \n**修改和删除组**  \n组属性修改\ngroupmod[OPTION]... group  \n```\ngroupmod  \n-n group_name: 新名字  \n-g GID: 新的GID  \n```\n组删除\n```\ngroupdel  \ngroupdelGROUP  \n```\n***\n更改组密码  \n组密码：gpasswd  \ngpasswd[OPTION] GROUP  \n-a user 将user添加至指定组中  \n-d user 从指定组中移除用户user  \n-A user1,user2,... 设置有管理权限的用户列表  \nnewgrp命令：临时切换主组  \n如果用户本不属于此组，则需要组密码  \n***\n**更改和查看组成员**  \ngroupmems[options] [action]  \n```\ngroupmems \n-g, --group groupname更改为指定组(只有root)  \nActions:  \n-a, --add username 指定用户加入组  \n-d, --delete username 从组中删除用户  \n-p, --purge 从组中清除所有成员  \n-l, --list 显示组成员列表  \ngroups [OPTION].[USERNAME]... 查看用户所属组列表  \n```\n**修改文件的属主和属组**  \n>修改文件的属主：chown  \nchown[OPTION]... [OWNER][:[GROUP]] FILE...  \n用法：\nchown  \nOWNER  \nOWNER:GROUP  \nGROUP  \n命令中的冒号可用.替换  \n-R: 递归  \nchown[OPTION]... --reference=RFILE FILE...  \n修改文件的属组：chgrp  \nchgrp[OPTION]... GROUP FILE...  \nchgrp[OPTION]... --reference=RFILE FILE...  \n-R 递归  \n***\n文件权限  \n文件的权限主要针对三类对象进行定义  \nowner: 属主, u  \ngroup: 属组, g  \nother: 其他, o  \n每个文件针对每类访问者都定义了三种权限  \nr: Readable  \nw: Writable  \nx: eXcutable  \n***\n# 修改文件权限  ***************重点\nchmod[OPTION]... OCTAL-MODE FILE...  \n-R: 递归修改权限  \nchmod[OPTION]... MODE[,MODE]... FILE...  \nMODE：  \n修改一类用户的所有权限：  \nu= g= o= ug= a= u=,g=  \n修改一类用户某位或某些位权限  \nu+ u-g+ g-o+ o-a+ a-+ -  \nchmod[OPTION]... --reference=RFILE FILE...  \n参考RFILE文件的权限，将FILE的修改为同RFILE   \n***\n## 新建文件和目录的默认权限  \numask值可以用来保留在创建文件权限  \n新建FILE权限: 666-umask  \n如果所得结果某位存在执行（奇数）权限，则将其权限+1  \n新建DIR权限: 777-umask  \n非特权用户umask是002  \nroot的umask是022  \numask: 查看  \numask#: 设定  \numask002  \numask–S 模式方式显示  \numask–p 输出可被调用  \n全局设置：/etc/bashrc用户设置：~/.bashrc  \n***\n### 可执行文件上SUID权限  \n任何一个可执行程序文件能不能启动为进程：取决发起者对程序文件是否拥有执行权限  \n启动为进程之后，其进程的属主为原程序文件的属主  \nSUID只对二进制可执行程序有效  \nSUID设置在目录上无意义  \n权限设定：  \n```\nchmodu+sFILE...  \nchmodu-s FILE...  \nchmodg+sDIR...  \nchmodg-s DIR...  \n```\n***\n### Sticky 位  \n具有写权限的目录通常用户可以删除该目录中的任何文件，无论该文件的权限或拥有权  \n在目录设置Sticky 位，只有文件的所有者或root可以删除该文件   \nsticky 设置在文件上无意义  \n权限设定：  \nchmodo+tDIR...  \nchmodo-t DIR...  \n\n# 访问控制列表***********************重点  \nACL：Access Control List，实现灵活的权限管理  \n除了文件的所有者，所属组和其它人，可以对更多的用户设置权限  \nCentOS7默认创建的xfs和ext4文件系统具有ACL功能  \nCentOS7之前版本，默认手工创建的ext4文件系统无ACL功能,需手动增加  \ntune2fs –o acl/dev/sdb1  \nmount –o acl/dev/sdb1 /mnt/test  \nACL生效顺序：所有者，自定义用户，自定义组，其他人 \n*** \n为多用户或者组的文件和目录赋予访问权限rwx  \n```\nmount -o acl/directory  \ngetfaclfile |directory  \nsetfacl-m u:wang:rwx file|directory  \nsetfacl-Rm g:sales:rwX directory  \nsetfacl-M file.aclfile|directory  \nsetfacl-m g:salesgroup:rw file| directory  \nsetfacl-m d:u:wang:rx directory  \nsetfacl-x u:wang file |directory  \nsetfacl-X file.acldirectory\n```\n**group权限**\nACL文件上的group权限是mask 值（自定义用户，自定义组，拥有组的最大权限）,而非传统的组权限  \n```\ngetfacl可看到特殊权限：flags  \n通过ACL赋予目录默认x权限，目录内文件也不会继承x权限  \nbase ACL 不能删除  \nsetfacl-k dir 删除默认ACL权限  \nsetfacl–b file1清除所有ACL权限  \ngetfaclfile1 | setfacl--set-file=-file2 复制file1的acl权限给file2  \n```\nmask只影响除所有者和other的之外的人和组的最大权限  \nMask需要与用户的权限进行逻辑与运算后，才能变成有限的权限(Effective Permission)  \n用户或组的设置必须存在于mask权限设定范围内才会生效setfacl-m mask::rxfile  \n--set选项会把原有的ACL项都删除，用新的替代，需要注意的是一定要包含UGO的设置，不能象-m一样只是添加ACL就可以  \n示例：  \nsetfacl --set u::rw,u:wang:rw,g::r,o::-file1  \n\n## 备份和恢ACL**************************************重点\n主要的文件操作命令cp和mv都支持ACL，只是cp命令需要加上-p 参数。但是tar等常见的备份工具是不会保留目录和文件的ACL信息  \n```\ngetfacl-R /tmp/dir1 > acl.txt  \nsetfacl -R -b /tmp/dir1  \nsetfacl-R --set-file=acl.txt/tmp/dir1  \nsetfacl--restore acl.txt  \ngetfacl -R /tmp/dir1  \n```","tags":["L·H"]},{"title":"epel源安装（Centos6.10和Centos7.5）","url":"%2F2018%2F09%2F28%2Fepel%E6%BA%90%E5%AE%89%E8%A3%85%EF%BC%88Centos6.10%E5%92%8CCentos7.5%EF%BC%89%2F","content":"\n\nCentos6.10\n```bash\nrpm -e epel-release                 #首先卸载以前装的epel 以免影响\nwget -P /etc/yum.repos.d/ http://mirrors.aliyun.com/repo/epel-6.repo   #下载阿里提供的epel\nyum clean all                                                                    #清理缓存\nyum makecache                                                        #生成缓存\nrm -rf /etc/yum.repos.d/*                              # 删除原来的epel源配置\nwget -P /etc/yum.repos.d/ http://mirrors.aliyun.com/repo/epel-6.repo http://mirrors.aliyun.com/repo/Centos-6.repo # 修改为阿里云的源\n\n```\nCentos7.5\n```bash\nrpm -e epel-release               #首先卸载以前装的epel 以免影响\nwget -P /etc/yum.repos.d/ http://mirrors.aliyun.com/repo/epel-7.repo    #下载阿里提供的epel\nyum clean all                        #清理缓存\nyum makecache                              #生成缓存\nrm -rf /etc/yum.repos.d/*              #删除原来的epel源配置\nwget -P /etc/yum.repos.d/ http://mirrors.aliyun.com/repo/epel-7.repo http://mirrors.aliyun.com/repo/Centos-7.repo  修改为阿里云的源\n\n```\n","tags":["L·H"]},{"title":"软件包管理","url":"%2F2018%2F09%2F27%2F%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%8F%8Ayum%E4%BB%93%E5%BA%93%E5%BB%BA%E8%AE%BE%2F","content":"\n# 软件包管理 \n程序包的来源\n获取程序包的途径：\n(1) 系统发版的光盘或官方的服务器\nCentOS镜像：\nhttps://www.centos.org/download/\nhttp://mirrors.aliyun.com\nhttp://mirrors.sohu.com\nhttp://mirrors.163.com\n(2) 项目官方站点\n(3) 第三方组织：\nFedora-EPEL：\nExtra Packages for Enterprise Linux\nRpmforge:RHEL推荐，包很全\n搜索引擎：\nhttp://pkgs.org\nhttp://rpmfind.net\nhttp://rpm.pbone.net\nhttps://sourceforge.net/\n(4) 自己制作\n注意：第三方包建议要检查其合法性\n来源合法性,程序包的完整性\n```bash\n[install-options]\n--test: 测试安装，但不真正执行安装，即dry run模式\n--nodeps：忽略依赖关系\n--replacepkgs| replacefiles\n--nosignature: 不检查来源合法性\n--nodigest：不检查包完整性\n--noscripts：不执行程序包脚本\n%pre: 安装前脚本--nopre\n%post: 安装后脚本--nopost\n%preun: 卸载前脚本--nopreun\n%postun: 卸载后脚本--nopostun\n```\n#  救援模式进入\ngetent +命令或者文件或者用户  看是否存在\n例子  getent f1.txt 看f1是否存在\n```bash\nrpm -qpi 查询还未安装的包内的文件\nrpm -qi  查询包的说信息\nrpm -q +命令名字 查询命令版本号    \nrpm -ql +tree  查询tree包里有什么文件\nrpm -q tree &> /dev/null ||rpm -ivh /cdrom/Package/tree-1.6.0-10.el7.x86_64.rpm  查询tree软件是否安装，如果没有安装则安装文件 \nrpm -e +软件名  卸载该软件\nrpm -upgrade 升级，一般情况下不用升级，直接卸载老版本安装新版本\nrpm --oldpackage 降级\nrpm -ivh +软件 + --force  强制安装 \nrpm -qa | wc -l  查询有多少个包\n```\n包校验\n\n包来源合法性验正及完整性验证\n完整性验证：SHA256\n来源合法性验证：RSA\n公钥加密\n对称加密：加密、解密使用同一密钥\n非对称加密：密钥是成对儿的\npublic key: 公钥，公开所有人\nsecret key: 私钥, 不能公开\n导入所需要公钥\n```bash\nrpm -K|checksigrpmfile检查包的完整性和签名\nrpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7\nCentOS 7发行版光盘提供：RPM-GPG-KEY-CentOS-7\nrpm -qa“gpg-pubkey*”\n```\n查询CentOS-7的完整性和签名\n```bash\ncat /misc/cd/RPM-GPG-KEY-CentOS-7  获取centos7公钥\nrpm --import /misc/cd/RPM-GPG-KEY-CentOS-7  导入公钥到系统\nrpm -K +软件包 显示出pgp md5 ok 查询完整性和签名\n```\n# YUM\n常用命令\n```bash\nyum install remove list info search groupinstall grouplist groupremove  history \nyum clean all \n```\nyum server\nyum repo 仓库\n包含*.rpm 包和 matadata 源数据（.rpm包需要的数据）\n安装文件 yum install +包的名字，不用补全\n\n## yum仓库建设************基于httpd服务的客户端仓库\n\n新建一台虚拟机作为仓库\n进入虚拟机输入 \n```bash\ncd /etc/yum.repo.d/\ndf      #查询光盘挂载位置\nls /misc/\nls /misc/cd  #触发光盘挂载到/misc/cd(神奇目录)\ndf \nmkdir bak   \nmv *.repo bak/      备份原来的repo\nls      然后看文件夹repodata在哪个目录，就将其所在的目录作为repo的路径\nls /misc/cd 看到repodata在这个路径，就将/misc/cd作为repo的路径\nvim base.repo\n写入\n[base]\nname=aliyun  或者bendiyuan  名字随便\nbaseurl=file:///misc/cd/  (http://  https://  ftp://  file://)网络源用http，（如阿里 https://mirrors.aliyun.com/centos/7/os/x86_64/）（6.7通用版本阿里源https://mirrors.aliyun.com/centos/$releasever/$basearch ）本地源用file  (******$releasever/$basearch***********$代表系统版本和架构）\ngpgcheck=0                     忽略完整性检查\nwq保存\nrepo本地包\n```\n\n## yum仓库建设***********基于httpd服务的服务器仓库\n\n```bash\nyum install httpd\ncd /var/www/html\nyum -ql httpd|grep service\nsystemctl start httpd    #浏览器输入虚拟机IP地址测试服务器是否运行 http://192.168.221.129/\npwd 查询是否在/var/www/html\necho 浩哥在此！ > index.html # http://192.168.221.129/ https://mirrors.tuna.tsinghua.edu.cn/centos/7/os/x86_64/ #使用清华源镜像\n/var/www/html\n/var/www/html/centos/7/os/x86_64/\n/var/www/html/centos/6/os/x86_64/\nmkdir -pv centos/{6,7}/os/x86_64/  #创建目录\n #在浏览器输入http://192.168.221.129/centos/  即可看到和清华源镜像一样的目录结构\nmount /dev/sr0 /var/www/html/centos/7/os/x86_64/\n进入http://192.168.221.129/centos/7/os/x86_64/  #可看到光盘镜像已上传\nvim /etc/yum.repos.d/base.repo\n写入\n[base]\nname=centos\nbaseurl=file:///misc/cd/\n#baseurl=http://192.168.221.129/centos/7/os/x86_6    IP地址非固定\ngpgcheck=0\n[epel]\nname=EPEL\nbaseurl=https://mirrors.aliyun.com/centos/$releasever/$basearchl\ngpgcheck=0\nenabled=0\n输入wq保存\nyum repolist\nyum clean all\nsystemctl start httpd 启动服务\n```\n>yum remove + 安装包的名称   卸载包\nyum repolist 列出仓库列表\nyum grouplist  查询包组\n常用包组Development tools\nyum groupinstall \"Development tools\"安装包组\n卸载多余网卡\n\n\n\n\n\n","tags":["L·H"]},{"title":"文件系统及文件权限","url":"%2F2018%2F09%2F26%2F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8F%8A%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%2F","content":"\n# 文件系统及文件权限\n##  命令帮助  \n\n### --help和-h选项  \n\n显示用法总结和参数列表  \n使用的大多数，但并非所有的  \n示例：  \n>date--help  \nUsage:date[OPTION]...[+FORMAT]or: date[-u|--utc|--universal][MMDDhhmm[[CC]YY][.ss]]  \n[]表示可选项  \nCAPS或<>表示变化的数据  \n...表示一个列表  \nx |y| z的意思是“x或y或z“  \n-abc的意思是-a -b –c  \n{ } 表示分组  \n\n\n### man命令\n\nman命令的操作方法：\n```\n使用less命令实现  \nspace, ^v, ^f, ^F: 向文件尾翻屏  \nb, ^b: 向文件首部翻屏  \nd, ^d: 向文件尾部翻半屏  \nu, ^u: 向文件首部翻半屏  \nRETURN, ^N, e, ^E or j or ^J: 向文件尾部翻一行  \ny or ^Y or ^P or k or ^K：向文件首部翻一行  \nq: 退出  \n#：跳转至第#行  \n1G: 回到文件首部  \nG：翻至文件尾部  \n```\n### man搜索  \n/KEYWORD:  \n以KEYWORD指定的字符串为关键字，从当前位置向文件尾部搜索；  \n不区分字符大小写；  \nn: 下一个  \nN：上一个  \nKEYWORD:\n以KEYWORD指定的字符串为关键字，从当前位置向文件首部搜索；不区分字符大小写；  \nn: 跟搜索命令同方向，下一个  \nN：跟搜索命令反方向，上一个  \n\n### info\nman常用于命令参考，GNU工具info适合通用文档参考\n没有参数,列出所有的页面  \ninfo 页面的结构就像一个网站  \n每一页分为“节点”  \n链接节点之前*  \ninfo [命令]  \n方向键，PgUp，PgDn导航  \nTab键移动到下一个链接  \nd 显示主题目录  \nHome 显示主题首部  \nEnter进入选定链接  \nn/p/u/l进入下/前/上一层/最后一个链接  \ns文字文本搜索  \nq退出info  \n***\n### 文件系统\n\n文件名规则   \n>boot 文件夹装的是引导文件  \netc文件夹装的是各种设置，配置文件等，等价于注册表  \nhome文件夹存放用户数据  \nbin（binary）二进制，装的是普通用户可执行的二进制程序  \nsbin是系统管理员常用的工具，tem文件夹装的是临时数据  \nvar文件夹装的是可变内容，系统日志（/var/log内）等  \nproc（process）进程，正在内存中运行的程序，该文件夹不在硬盘上  \nmount /dev/硬盘号/  挂载硬盘  \n\n### 文件命名\n**Linux系统对大小写不敏感，常用的Linux文件系统（xfs；ext4）对大小写敏感**\n而Linux系统识别fat文件格式时对大小写不敏感\n文件名最长255个字节   \n包括路径在内文件名称最长4095个字节  \n蓝色-->目录绿色-->可执行文件红色-->压缩文件浅蓝色-->链接文件灰色-->其他文件  \n除了斜杠和NUL,所有字符都有效.但使用特殊字符的目录名和文件不推荐使用，有些字符需要用引号来引用它们    \n标准Linux文件系统（如ext4），文件名称大小写敏感  \n例如：MAIL,Mail,mail, mAiL  \n## 文件系统结构\n>/boot：引导文件存放目录，内核文件(vmlinuz)、引导加载器(bootloader, grub)都存放于此目录  \n/bin：供所有用户使用的基本命令；不能关联至独立分区，OS启动即会用到的程序  \n/sbin：管理类的基本命令；不能关联至独立分区，OS启动即会用到的程序  \n/lib：启动时程序依赖的基本共享库文件以及内核模块文件(/lib/modules)  \n/lib64：专用于x86_64系统上的辅助共享库文件存放位置  \n/etc：配置文件目录  \n/home/USERNAME：普通用户家目录  \n/root：管理员的家目录  \n/media：便携式移动设备挂载点  \n/mnt：临时文件系统挂载点  \n/dev：设备文件及特殊文件存储位置  \nb: block device，随机访问  \nc: character device，线性访问  \n/opt：第三方应用程序的安装位置  \n/srv：系统上运行的服务用到的数据  \n/tmp：临时文件存储位置  \n/usr: universal shared, read-only data  \nbin: 保证系统拥有完整功能而提供的应用程序  \nsbin:  \nlib：32位使用  \nlib64：只存在64位系统  \ninclude: C程序的头文件(header files)  \nshare：结构化独立的数据，例如doc, man等  \nlocal：第三方应用程序的安装位置  \nbin, sbin, lib, lib64, etc, share  \n/var: variable data files  \ncache: 应用程序缓存数据目录  \nlib: 应用程序状态信息数据  \nlocal：专用于为/usr/local下的应用程序存储可变数据；  \nlock: 锁文件  \nlog: 日志目录及文件  \nopt: 专用于为/opt下的应用程序存储可变数据；  \nrun: 运行中的进程相关数据,通常用于存储进程pid文件  \nspool: 应用程序数据池  \ntmp: 保存系统两次重启之间产生的临时数据  \n/proc: 用于输出内核与进程信息相关的虚拟文件系统  \n/sys：用于输出当前系统上硬件设备相关信息虚拟文件系统  \n/selinux: security enhanced Linux，selinux相关的安全策略等信息的存储位置  \n\n## 本节笔记\n***\nls -R 列出当前文件夹的目录及子目录（所以文件和目录）  \nls -r 反转顺序   \n文件有三个时间属性，  \n修改时间mtime（modify time）  \n读取时间atime（access time）ll --time=atime  查询文件读取的时间  \n元数据的更改时间 ctime （change time）  \nstat +文件名  查询文件的三个时间  \n\n# 绝对和相对路径                 （重点）\n***\n绝对路径：  \n以正斜杠开始  \n完整的文件的位置路径  \n可用于任何想指定一个文件名的时候  \n相对路径名   \n不以斜线开始  \n指定相对于当前工作目录或某目录的位置  \n可以作为一个简短的形式指定一个文件名  \n基名：basename +文件可以取文件的基名  \n目录名：dirname +文件可以取文件的目录名  \n***\n### 列出目录内容  \n列出当前目录的内容或指定目录  \n用法：ls [options] [files_or_dirs]  \n示例:  \n```\nls -a包含隐藏文件  \nls -l显示额外的信息  \nls -R目录递归通过  \nls -ld目录和符号链接信息  \nls -1 文件分行显示  \nls –S 按从大到小排序  \nls –t 按mtime排序  \nls –u 配合-t选项，显示并按atime从新到旧排序  \nls –U 按目录存放顺序显示  \nls –X 按文件后缀排序  \nls /var l{0...9}  \nls /etc rc{0...6}*  \n```\n\n*** \n .>boot/111  快速清空文件111  \ntouch ＋文件名创建空文件，若该文件已存在，就刷新文件的时间  \n.  >> ＋文件名 创建空文件，若存在，不刷新文件时间，追加，重定向  \nrename +conf conf.bak *.conf 可以批量修改多个后缀为conf的文件名字  \n~或者-开头的文件，要创建或者删除是只需在~或者-前加./就可以了    \n```\ndate 0921221392018直接改时间                              （重点）  \ndata +%w -d '-2 day'显示两天前是星期几  \ndata +%F 显示年月日  \ndata +'%F %T' 显示年月日和时间  \ndata +%Y 显示年  \ndata +%Y%M%D 显示年月日  \nwhatis +命令  查询该命令作用=man -f  \nmandb 生成whatis数据库 centos6  \nmakewhatis 生成whatis数据库  centos7  \n```\n### **安装命令工具                                                （重点）**  \ndf查找sr0挂载光盘，若无挂载光盘则创建挂载点 \n```\ndf -h    #查看光盘是否已挂载\nmkdir /data/cdrom     #新建挂载目录\nmount /dev/sr0/data/cdrom               #挂载光盘到目录，然后执行下一步  \ndf                                #查找sr0挂载路径\nrpm -ivh +挂载光盘目录（右键复制media），再输入工具首字母补全，回车安装  \n```\n***\n## **file**  \nfile content 文件内容  \nfile metadata 文件元数据  \n\ninode number 文件节点 \n```\nls -i 查询文件节点编号 \n```\n节点编号存放在/boot，节点编号用完后无法存放文件                   （面试）  \n```\nls -di +文件夹  查询挂载节点位置  \nls -di /data /boot /  centos6 这三个节点为2 centos7上着三个节点为64  \n```\n移动复制的区别（重点）原理层面  \n```\ncp /dir1/f1 /dir2/f2  \nmv /dir1/f1 /dir2/f2  \n```\n相对路径（重点） 硬链接和软链接的区别？         \n通俗来说：  \n硬链接：对一个文件，起多个文件名  \n软连接：原始文件一般路径用相对路劲，\n***\n### 相对路径一定相对于软连接文件的路径  **********************  (重点   看录屏)  \n>1.是否是同一个文件   硬链接是同一个文件，软链接不上是同一个  \n2.是否跨分区  \n3.链接数增长？  \n4.inode number 是否相同？  \n5.原始文件删除，链接文件可否访问？  \n6.大小？  \n7.支持目录？  \n8.相对路径  \n节点表  \n***\n例子：\n```\nln -s ../../dev/zero  d1/d2/zero-link  \n```\n0输入  \n1输出  \n2错误  \n命令+ &> /dev/null  将输出结果直接扔进null（垃圾箱），不在屏幕显示  \n***\n## 文件通配符                                            （重点）  \n\n>*匹配零个或多个字符  \n?匹配任何单个字符  \n~ 当前用户家目录  \n~mage 用户mage家目录  \n~+ 当前工作目录  \n~-前一个工作目录  \n[0-9]匹配数字范围  \n[a-z]：字母  \n[A-Z]：字母  \n[wang]匹配列表中的任何的一个字符  \n[^wang]匹配列表中的所有字符以外的字符  \n预定义的字符类：man 7 glob  \n[:digit:]：任意数字，相当于0-9  \n[:lower:]：任意小写字母  \n[:upper:]: 任意大写字母  \n[:alpha:]: 任意大小写字母  \n[:alnum:]：任意数字或字母  \n[:blank:]：水平空白字符  \n[:space:]：水平或垂直空白字符  \n[:punct:]：标点符号  \n[:print:]：可打印字符  \n[:cntrl:]：控制（非打印）字符  \n[:graph:]：图形字符  \n[:xdigit:]：十六进制字符  \n创建空文件和刷新时间  \n## touch命令：                                              （重点）  \ntouch [OPTION]... FILE...  \n```\n-a                                     #仅改变atime和ctime  \n-m                                     #仅改变mtime和ctime  \n-t [[CC]YY]MMDDhhmm[.ss]               #指定atime和mtime的时间戳  \n-c                                     #如果文件不存在，则不予创建  \n```\n\n例子：\n>复制文件和目录cp                                    （重点）  \ncp[OPTION]... [-T] SOURCE DEST  \ncp[OPTION]... SOURCE... DIRECTORY  \ncp[OPTION]... -t DIRECTORY SOURCE...  \ncpSRC DEST  \nSRC是文件：  \n如果目标不存在：新建DEST，并将SRC中内容填充至DEST中  \n如果目标存在：  \n如果DEST是文件：将SRC中的内容覆盖至DEST中  \n基于安全，建议为cp命令使用-i选项  \n如果DEST是目录：在DEST下新建与原文件同名的文件，并将SRC中内容填充至新文件中  \ncpSRC... DEST  \nSRC...：多个文件  \nDEST必须存在，且为目录，其它情形均会出错  \ncpSRC DEST  \nSRC是目录：此时使用选项：-r   \n如果DEST不存在：则创建指定目录，复制SRC目录中所有文件至DEST中   \n如果DEST存在：  \n如果DEST是文件：报错  \n如果DEST是目录：  \n\n## cp常用选项  \n```\ncp\n-i：覆盖前提示–n:不覆盖，注意两者顺序  \n-r, -R: 递归复制目录及内部的所有内容  \n-a: 归档，相当于-dR--preserv=all  \n-d：--no-dereference --preserv=links 不复制原文件，只复制链接名  \n--preserv[=ATTR_LIST]  \n```\nmode: 权限   \nownership: 属主属组  \ntimestamp:  \nlinks  \nxattr  \ncontext  \nall  \n-p: 等同--preserv=mode,ownership,timestamp  \n-v: --verbose  \n-f: --force  \n-u:--update 只复制源比目标更新文件或目标不存在的文件  \n-b:目标存在，覆盖前先备份  \n--backup=numbered 目标存在，覆盖前先备份加数字后缀    \n##  本节笔记  \n快捷键  \n```\ncp +文件路径/a文件名 文件路径/a新文件名  #将a文件复制到另一文件夹并改名  \ncp +r +a目录  +b目录  将a目录复制到b目录，成为b目录的子目录  \ncp -a 常用来备份，保留复制文件的所有属性  \ncp file1 file1.bak  将file1文件备份为file1.bak  \n等同于cp file1{，.bak}  \nmv +a文件 +b文件  将文件a改名为文件b  \nmv +a文件 +文件夹  移动a文件到文件夹  \nmv -t +文件夹+多个文件  把多个文件移动到目标文件夹  \n移动和重命名文件  \nmv [OPTION]... [-T] SOURCE DEST  \nmv [OPTION]... SOURCE... DIRECTORY  \nmv [OPTION]... -t DIRECTORY SOURCE...  \n```\n常用选项：\n```\nmv\n-i: 交互式  \n-f: 强制  \n-b: 目标存在，覆盖前先备份  \n```\n**删除**   \n```\nrm[OPTION]... FILE...  \n常用选项：  \n-i交互式  \n-f强制删除  \n-r递归  \n--no-preserve-root 删除/  \n示例：  \nrm-rf/ 慎用   \n目录操作  \ntree 显示目录树  \n-d: 只显示目录  \n-L level：指定显示的层级数目  \n-P pattern: 只显示由指定pattern匹配到的路径  \n```\n### mkdir创建目录                                                 练习 \n>mkdir\n-p: 存在于不报错，且可自动创建所需的各目录  \n-v: 显示详细信息  \n-m MODE: 创建目录时直接指定权限  \nrmdir删除空目录  \n-p: 递归删除父空目录  \n-v: 显示详细信息  \nrm-r递归删除目录树  \n标准输入和输出  \n程序：指令+数据  \n读入数据：Input  \n输出数据：Output  \n打开的文件都有一个fd: file descriptor (文件描述符)  \nLinux给程序提供三种I/O设备  \n标准输入（STDIN）－0默认接受来自键盘的输入  \n标准输出（STDOUT）－1默认输出到终端窗口  \n标准错误（STDERR）－2默认输出到终端窗口  \n\n## I/O重定向：改变默认位置  \n\n### 把输出和错误重新定向到文件                                   （重点）  \nSTDOUT和STDERR可以被重定向到文件  \n命令操作符号文件名  \n支持的操作符号包括：  \n_> 把STDOUT重定向到文件  \n2>把STDERR重定向到文件  \n&>把所有输出重定向到文件  \n_> 文件内容会被覆盖  \nset –C 禁止将内容覆盖已有文件,但可追加  \n_>| file 强制覆盖  \nset +C 允许覆盖  \n_>> 原有内容基础上，追加内容  \n2>覆盖重定向错误输出数据流  \n2>> 追加重定向错误输出数据流  \n标准输出和错误输出各自定向至不同位置  \nCOMMAND > /path/to/file.out2> /path/to/error.out  \n合并标准输出和错误输出为同一个数据流进行重定向  \n&>覆盖重定向  \n&>> 追加重定向  \nCOMMAND > /path/to/file.out2>&1 （顺序很重要）  \nCOMMAND >> /path/to/file.out2>&1  \n()：合并多个程序的STDOUT  \n(cal2007;cal2008)> all.txt  \n\n## 本节笔记\n\n### 重定向   \n.> 覆盖  \n.>>追加不覆盖原文件内容   \n2>将错误信息重定向到文件中  \n1+到100  echo {1..100} | tr ' ' + |bc  \n命令（mail）  << EOF  写一封信，直到输入EOF结束   \n## 文件权限 \nrwx  \nr--4   读取权限  \nw--2   写入权限  \nx--1   执行权限  \n-rwxrwxrwx -为文件类型 777  \n-rw-rw-rw- 只有读写权限，没有执行权限666  \n$ chgrp +组+用户 将此用户改为此组  \ncat与tac相反 \n```\nabcd  dcba  \nhead  +命令 默认显示该文件的前十行  \nhead -n +数字  显示文件的前几行  \ntail +f跟踪文件号，文件被删除就失效  \ntail +F跟踪文件名，文件被删除后再新建的同名文件继续跟踪  \n```\n# tr命令                                 （重点）  \ntr转换和删除字符  \ntr[OPTION]... SET1 [SET2]  \n选项：  \n```\ntr\n-c–C --complement：取字符集的补集  \n-d--delete：删除所有属于第一字符集的字符  \n-s--squeeze-repeats：把连续重复的字符以单独一个字符表示  \n-t--truncate-set1：将第一个字符集对应字符转化为第二字符集对应的字符  \n[:alnum:]：字母和数字  \n[:alpha:]：字母  \n[:cntrl:]：控制（非打印）字符  \n[:digit:]：数字  \n[:graph:]：图形字符  \n[:lower:]：小写字母  \n[:print:]：可打印字符  \n[:punct:]：标点符号  \n[:space:]：空白字符  \n[:upper:]：大写字母  \n[:xdigit:]：十六进制字符  \n```\n### 从文件中导入STDIN    ....................................................（重点）（重点）  \n使用<来重定向标准输入  \n某些命令能够接受从文件中导入的STDIN  \ntr‘a-z'‘A-Z'</etc/issue  \n该命令会把/etc/issue中的小写字符都转换成写写字符  \ntr–d abc< /etc/fstab删除fstab文件中的所有abc中任意字符  \ncat > file  \nmage  \nwangxiaochun  \n按ctrl+d离开，可以使用文件来代替键盘的输入  \nCat > filea< fileb  \n***\n把多行发送给STDIN  ................................... （重点）（重点）练习  \n使用“<<终止词”命令从键盘把多行重导向给STDIN  \n直到终止词位置的所有文本都发送给STDIN  \n有时被称为就地文本（heretext） \n例如：\n```\n'mail-s'PleaseCall'admin@magedu.com<<END  \n>HiWang,  \n>  \n>Pleasegivemeacallwhenyougetin.Wemayneed  \n>todosomemaintenanceonserver1.  \n>  \n>Detailswhenyou'reon-site  \n>Zhang  \n>END  \n```\n例子：  \n```\ncat >f1 回车  \naa  \nbb  \ncc  \n                              #回车一次输出aa，再回车，输出bb，再回车，输出cc,此为单行重定向  \ncat >f1 <<b                           #回车，以b结尾，（常用EOF结尾）  \n>aa  \n>bb  \n>cc  \n>b  \n以b结尾，输出：  \naa  \nbb  \ncc             #此为多行重定向  \n```\n***\n# 管道     ................... （重点）练习  \n管道（使用符号“|”表示）用来连接命令  \n命令1 | 命令2 | 命令3 | …  \n将命令1的STDOUT发送给命令2的STDIN，命令2的STDOUT发送到命令3的STDIN  \nSTDERR默认不能通过管道转发，可利用2>&1 或|& 实现  \n最后一个命令会在当前shell进程的子shell进程中执行用来  \n组合多种工具的功能  \n```\nls| tr‘a-z' ‘A-Z'  \n```\nless ：一页一页地查看输入  \n```\nls-l/etc|less  \n```\nmail：通过电子邮件发送输入  \n```\necho'testemail'|mail-s 'test'user@example.com  \n```\nlpr：把输入发送给打印机  \necho'testprint'|lpr-Pprinter_name  \n示例:  \n将/home 里面的文件打包，但打包的数据不是记录到文件，而是传送到stdout，  \n经过管道后，将tar -cvf-/home 传送给后面的tar -xvf-,  \n后面的这个-则是取前一个命令的stdout，因此，就不需要使用临时file了  \ntar -cvf-/home | tar -xvf-  \n\n\n","tags":["L·H"]},{"title":"计算机基础","url":"%2F2018%2F09%2F25%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%2F","content":"\n\n\n# 计算机基础\n## 服务器\n服务器按应用功能可分为：\n\nWeb服务器、数据库服务器、文件服务器、中间件应用服务器、日志服务器、监控服务器，程序版本控制服务器、虚拟机服务器、邮件服务器、打印服务器、域控制服务器、多媒体服务器、通讯服务器、ERP服务器等。\n服务器按外形分类：\n塔式服务器、刀片式服务器、机架式服务器。\n## 服务器的尺寸\n服务器宽度标准为19英寸（48.26cm），\n高度（厚度）为1U=1.75英寸=44.45毫米\n服务器一般有1U,2U,4U...\n深度为600mm，800mm，900mm，1000mm\n服务器机柜通常为42U约两米高。\n放服务器机柜一般用600mm,深1000mm，高2000mm；\n放网络设备机柜一般用深度为800mm。\n## 服务器常用CPU\nIntel：   \n    Xeon 志强  \n    Itanium 安腾  \n AMD：  \n     ALthion \nIBM：  \n    power  \n### CPU频率  \n 主频： \n\n 主频是CPU的时钟频率(CPU Clock Speed)，是CPU运算时的工作的频率（1秒内发生的同步脉冲数）的简称。单位是Hz。\n 外频：\n \n 系统总线的工作频率， CPU与外部（主板芯片组）交换数据、指令的工作时钟频率。 \n 倍频：\n  \n 倍频则是指CPU外频与主频相差的倍数。  \n 三者关系是：主频=外频x倍频  \n 常见的热插拔设备：硬盘，电源，PCI设备，风扇等  \n 裸漏在机箱外的设备一般都支持热插拔。\n### 服务器内存  \n内存带宽是内存与北桥芯片之间的数据传输率  \n内存断电后数据丢失  \n外存断电后数据可以保存  \n内存带宽=内存总线频率X数据总线位数/8  \n1Byte（字节）=8bit（位）  \n100Mbps  1G bit s  \n100Mbps带宽=12.8MB/s 下载速度   \n1B=8b  Byte  bit\n### 硬盘\n硬盘接口类型：\n\n>IDE接口：硬盘接口规范，采用ATA技术规范  \nSCSI接口：应用于小型机上的高速数据传输技术 \nSATA接口： Serial ATA，提高传输速率，支持热插拔 \nSAS接口： Serial Attached SCSI，兼容SATA  \n\n目前主流的硬盘接口为SATA和SAS接口 \n# 存储基础知识--存储网络    \nDAS-----直接连接存储(Direct Attached Storage)  \n数据块     磁盘和服务器可以分离，易于管理，但数据较为分散，连接距离短\n\nNAS-----网络连接存储(Network Attached Storage)  \n文件    不占用应用服务器资源，即插即用，用于文件服务器，不适合存储量大的设备\n\nSAN-----存储区域网络(Storage Area Networks)  \n数据块   高扩展性，数据集中易于管理，贵且安装和升级复杂    \n# 操作系统\nOS分类：  \n\n服务器OS：RHEL, CentOS,Windows Server,AIX  \n\n桌面OS：Windows 10,Windows 7,Mac OS，Fedora \n\n移动设备OS：Andriod,IOS,YunOS  \n\n## 开发接口标准   \nABI接口：应用程序与OS之间的底层接口，允许编译好的目标代码在使用兼容ABI的系统中无需改动就能运行 \n\nAPI接口：API定义了源代码和库之间的接口，因此同样的源代码可以在支持这个API的任何系统中编译  \n# Linux哲学思想  \n>一切都是一个文件（包括硬件）  \n>小型，单一用途的程序   \n>链接程序，共同完成复杂的任务  \n避免令人困惑的用户界面  \n配置数据存储在文本中  \n# 终端terminal  \n### 设备终端  \n键盘鼠标显示器  \n### 物理终端（/dev/console ）  \n控制台console  \n### 虚拟终端  \n(tty：teletypewriters，/dev/tty# #为[1-6])\ntty可有n个，Ctrl+Alt+F[1-6]  \n### 图形终端  \n/dev/tty7 ）startx, xwindows  \nCentOS 6: Ctrl + Alt + F7\nCentOS 7: 在哪个终端启动，即位于哪个虚拟终端\n### 串行终端  \n（/dev/ttyS# ）\nttyS  \n### 伪终端  \n（pty：pseudo-tty，/dev/pts/# ）\npty, SSH远程连接  \n### 查看当前的终端设备：  \ntty  \n# 交互式接口  \n交互式接口：启动终端后，在终端设备附加一个交互式应用程序  \nGUI：Graphic User Interface   \nX protocol, window manager, desktop  \nDesktop:\nGNOME (C, 图形库gtk)，  \nKDE (C++,图形库qt)  \nXFCE (轻量级桌面)  \n\nCLI：Command Line Interface \n\nshell程序：sh(bourn 史蒂夫·伯恩)cshtcshksh(korn)bash (bourn again shell)GPL zsh  \n# 命令提示符\n命令提示符：prompt  \n[root@localhost~]#  \n#管理员  \n$ 普通用户  \n显示提示符格式  \n[root@localhost~]#echo $PS1  \n修改提示符格式  \nPS1=\"\\[\\e[1;5;41;33m\\][\\u@\\h \\W]\\\\$\\[\\e[0m\\]\"  \n>\\e \\033      ......               \\u 当前用户  \n\\h 主机名简称      ......     \\H 主机名  \n\\w 当前工作目录    ......    \\W 当前工作目录基名  \n\\t 24小时时间格式   ......    \\T 12小时时间格式  \n\\! 命令历史数     ......     \\# 开机后命令历史数 \n# 常见命令及使用  \n## 内部命令\n\n内部命令：由shell自带的，而且通过某命令形式提供\n\n```\nhelp或者enable              #查询全部内部命令  \ntype+命令            #查询命令是否为内部命令，是则显示builtin，不是则显示路径  \nenable -n cmd          #禁用内部命令  \nenable -n+命令     #禁用命令   \nenable -n                #查询被禁用的命令  内部命令执行速度快  \n优先找内部命令，如果没有再去外部找外部命令\n```\n## 外部命令  \n外部命令：在文件系统路径下有对应的可执行程序文件\n查看路径：\n>which -a |--skip-alias; whereis  \nwhich+命令查询命令路径  \nwhereis+命令 查询命令路径及其配置文件，更详细  \n\n# 执行外部命令  \n### Hash缓存表  \n系统初始hash表为空，当外部命令执行时，默认会从PATH路径下寻找该命令，找到后会将这条命令的路径记录到hash表中，当再次使用该命令时，shell解释器首先会查看hash表，存在将执行之，如果不存在，将会去PATH路径下寻找。利用hash缓存表可大大提高命令的调用速率  \n长命令 \n### hash常见用法  \n\n```\nhash 显示hash缓存  \nhash –l 显示hash缓存，可作为输入使用  \nhash –p path name 将命令全路径path起别名为name  \nhash –t name 打印缓存中name的路径  \nhash –d name 清除name缓存  \nhash –r 清除缓存  \n```\n\n\n\n# 命令别名\nalias +自定义名字=一长串命令，输入自定义名字可以代替  \n在命令行中定义的别名，仅对当前shell进程有效  \n如果想永久有效，要定义在配置文件中  \n仅对当前用户：~/.bashrc  \n对所有用户有效：/etc/bashrc  \nunalias+自定义命令  取消这个别名  \n### 命令格式\n>-n  短选项  例如：-l, -h  \n--n长选项  例如：--all, --human-readable  \n-e加\\ 解释功能  \n\n# 日期和时间  \nLinux的两种时钟  \n系统时钟：由Linux内核通过CPU的工作频率进行的\n硬件时钟：主板\n相关命令  \n\n```\ndate 显示和设置系统时间  \ndate +%s   \ndate -d @1509536033  \nhwclock，clock: 显示硬件时钟  \n-s, --hctosys以硬件时钟为准，校正系统时钟  \n-w, --systohc以系统时钟为准，校正硬件时钟  \n时区：/etc/localtime  \n显示日历：cal–y  \n```\n\n\n\n# 简单命令\n\n```\n关机：halt, poweroff  \n重启：reboot  \n-f: 强制，不调用shutdown  \n-p: 切断电源  \n关机或重启：shutdown  \nshutdown [OPTION]... [TIME] [MESSAGE]  \n-r: reboot  \n-h: halt  \n-c：cancel  \nTIME：无指定，默认相当于+1（CentOS7）  \nnow: 立刻,相当于+0  \n+m: 相对时间表示法，几分钟之后；例如+3  \nhh:mm: 绝对时间表示，指明具体时间  \n例如：shutdown +5 -h  5分钟后关机  \nshutdown +5 -r  5分钟后重启  \nshutdown  -c  取消关机  \n用户登录信息查看命令：\nwhoami: 显示当前登录有效用户\nwho: 系统当前所有的登录会话\nw: 系统当前所有的登录会话及所做的操作\n```\n## screen命令（重点）  \n>创建新screen会话  \nscreen –S [SESSION]  \n加入screen会话  \nscreen –x [SESSION]  \n退出并关闭screen会话  \nexit  \n剥离当前screen会话  \nCtrl+a+d  \n显示所有已经打开的screen会话  \nscreen -ls  \n恢复某screen会话  \nscreen -r [SESSION]\n\n例如：\n```\nscreen -S help  创建一个名为help的会话  \nscreen -ls 查看其他人创建的会话  \nscreen -x help  加入名为help的会话，两个终端可以同步操作  \nscreen 可以单独开一个终端，在开的临时会话中做任务，即使此时网络或者系统出现问题，也不会丢失任务  \n```\n## echo命令  \n\n功能：显示字符  \n语法：echo [-neE][字符串]  \n说明：echo会将输入的字符串送往标准输出。输出的字符串间以空白字符隔开, 并在最后加上换行号  \n选项：  \n>-E （默认）不支持\\解释功能  \n-n 不自动换行  \n-e 启用\\字符的解释功能  \n\n显示变量  \necho \"$VAR_NAME” 变量会替换，弱引用  \necho '$VAR_NAME’  变量不会替换，强引用   \n例如：\n```\necho  {1,2,3}  \n1 2 3   \necho 1 2 3   \n1 2 3  \necho file {1,2,3}  \nfile1 file2 file3  \necho file {1,2,3}  \necho file {1,2,3}.{txt}  \nfile1.txt file2.txt file3.txt  \necho file {1,2,3}.{txt,log}  \nfile1.txt file1.log file2.txt file2.log   file3.txt file3.log  \n```\n启用命令选项-e 若字符串中出现以下字符，则特别加以处理，而不会将它当成一般文字输出 \n```\necho\n>\\a 发出警告声  \n\\b 退格键  \n\\c 最后不加上换行符号  \n\\n 换行且光标移至行首  \n\\r 回车，即光标移至行首，但不换行  \n\\t 插入tab  \n\\\\插入\\字符  \n\\0nnn 插入nnn（八进制）所代表的ASCII字符  \necho -e '\\033[43;31;5mmagedu\\033[0m'  \n\\xHH插入HH（十六进制）所代表的ASCII数字（man 7 ascii）  \n```\n# 命令行历史  \n保存你输入的命令历史。可以用它来重复执行命令  \n登录shell时，会读取命令历史文件中记录下的命令~/.bash_history  \n登录进shell后新执行的命令只会记录在缓存中；这些命令会用户退出时“追加”至命令历史文件中  \n重复前一个命令，有4种方法  \n>重复前一个命令使用上方向键，并回车执行  \n按!! 并回车执行  \n输入!-1 并回车执行  \n按Ctrl+p并回车执行  \n```\n!:0 执行前一条命令（去除参数）  \nCtrl + n 显示当前历史中的下一条命令，但不执行  \nCtrl + j 执行当前命令  \n!n 执行history命令输出对应序号n的命令  \n!-n 执行history历史中倒数第n个命令  \n!string 重复前一个以“string”开头的命令  \n!?string 重复前一个包含string的命令  \n!string:p仅打印命令历史，而不执行  \n!$:p 打印输出!$ （上一条命令的最后一个参数）的内容  \n!*:p打印输出!*（上一条命令的所有参数）的内容  \n^string删除上一条命令中的第一个string  \n^string1 ^string2将上一条命令中的第一个string1替换为string2  \n!:gs/string1/string2将上一条命令中所有的string1都替换为string2  \n```\n>使用up（向上）和down（向下）键来上下浏览从前输入的命令  \nctrl-r来在命令历史中搜索命令  \n（reverse-i-search）`’：  \nCtrl+g：从历史搜索模式退出  \n要重新调用前一个命令中最后一个参数  \n!$ 表示   \nEsc, .（点击Esc键后松开，然后点击. 键）  \nAlt+ .（按住Alt键的同时点击. 键）  \n\n>command !^ 利用上一个命令的第一个参数做cmd的参数  \ncommand !$ 利用上一个命令的最后一个参数做cmd的参数  \ncommand !n:* 调用第n条命令的所有参数  \ncommand !string:^ 从命令历史中搜索以string 开头的命令，并获取它的第一个参数  \ncommand !string:$ 从命令历史中搜索以string 开头的命令,并获取它的最后一个参数  \ncommand !string:n 从命令历史中搜索以string 开头的命令，并获取它的第n个参数  \ncommand !string:* 从命令历史中搜索以string 开头的命令，并获取它的所有参数  \n\n# 命令history  \n```\nHISTSIZE：命令历史记录的条数  \nHISTFILE：指定历史文件，默认为~/.bash_history  \nHISTFILESIZE：命令历史文件记录历史的条数  \nHISTTIMEFORMAT=“%F %T “ 显示时间  \nHISTIGNORE=“str1:str2*:… “ 忽略str1命令，str2开头的历史  \n```\n控制命令历史的记录方式：  \n环境变量：HISTCONTROL  \n```\nignoredups默认，忽略重复的命令，连续且相同为“重复”  \nignorespace忽略所有以空白开头的命令  \nignoreboth相当于ignoredups, ignorespace的组合  \n```\nerasedups删除重复命令  \nexport 变量名=\"值“  \n存放在/etc/profile 或~/.bash_profile  \n# bash的快捷键(重点)  \n```\nCtrl + l清屏，相当于clear命令  \nCtrl + o执行当前命令，并重新显示本命令  \nCtrl + s阻止屏幕输出，锁定  \nCtrl + q允许屏幕输出  \nCtrl + c终止命令  \nCtrl + z挂起命令  \nCtrl + a光标移到命令行首，相当于Home  \nCtrl + e光标移到命令行尾，相当于End  \nCtrl + f光标向右移动一个字符  \nCtrl + b光标向左移动一个字符  \nAlt + f光标向右移动一个单词尾  \nAlt + b光标向左移动一个单词首  \nCtrl + xx光标在命令行首和光标之间移动  \nCtrl + u从光标处删除至命令行首  \nCtrl + k从光标处删除至命令行尾  \nAlt + r 删除当前整行  \nCtrl + w从光标处向左删除至单词首  \nAlt + d从光标处向右删除至单词尾  \nCtrl + d删除光标处的一个字符  \nCtrl + h删除光标前的一个字符  \nCtrl + y将删除的字符粘贴至光标后  \nAlt + c从光标处开始向右更改为首字母大写的单词  \nAlt + u从光标处开始，将右边一个单词更改为大写  \nAlt + l从光标处开始，将右边一个单词更改为小写  \nCtrl + t交换光标处和之前的字符位置  \nAlt + t交换光标处和之前的单词位置  \nAlt + N提示输入指定字符后，重复显示该字符N次 \n```\n注意：Alt组合快捷键经常和其它软件冲突  \n\n### whatis\nwhatis +命令  查询命令功能      \n鼠标左键选择命令，右键可以直接粘贴该命令      \nmakewhatis安装whatis数据库   8.163.128 在伪终端直接输入用户名和密码登录终端  \n\n# 好玩的欢迎界面！\nnano /etc/motd    将下面图案写入motd，按ctrl+x，然后按enter保存，形成开机欢迎界面  \n\n------------------  \n                              _.._        ,------------.\n                           ,'      `.    ( I want you! )\n                          /  __) __` \\    `-,----------'\n                         (  (`-`(-')  ) _.-'\n                         /)  \\  = /  (  \n                        /'    |--' .  \\  \n                       (  ,---|  `-.)__`  \n                        )(  `-.,--'   _`-.  \n                       '/,'          (  Uu\",\n                        (_       ,    `/,-' )\n                        `.__,  : `-'/  /`--'\n                          |     `--'  |\n                          `   `-._   /\n                           \\        (\n                           /\\ .      \\.  \n                          / |` \\     ,-\\\n                         /  \\| .)   /   \\\n                        ( ,'|\\    ,'     :\n                        | \\,`.`--\"/      }\n                        `,'    \\  |,'    /\n                       / \"-._   `-/      |\n                       \"-.   \"-.,'|     ;\n                      /        _/[\"---'\"\"]\n                     :        /  |\"-     '\n                     '           |      /\n                                 `      |\n\n  ","tags":["L·H"]},{"title":"Markdown写作格式","url":"%2F2018%2F09%2F24%2FMarkdown%E5%86%99%E4%BD%9C%E6%A0%BC%E5%BC%8F%2F","content":"\n\n\n\n# Markdown写作格式\n\n你好！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。\n\n## 新的改变\n\n我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客：\n\n 1. **全新的界面设计** ，将会带来全新的写作体验；\n 2. 在创作中心设置你喜爱的代码高亮样式，Markdown **将代码片显示选择的高亮样式** 进行展示；\n 3. 增加了 **图片拖拽** 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；\n 4. 全新的 **KaTeX数学公式** 语法；\n 5. 增加了支持**甘特图的mermaid语法[^1]** 功能；\n 6. 增加了 **多屏幕编辑** Markdown文章功能；\n 7. 增加了 **焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置** 等功能，功能按钮**位于编辑区域与预览区域中间**；\n 8. 增加了 **检查列表** 功能。\n [^1]: [mermaid语法说明](https://mermaidjs.github.io/)\n\n## 功能快捷键\n\n撤销：<kbd>Ctrl/Command</kbd> + <kbd>Z</kbd>\n重做：<kbd>Ctrl/Command</kbd> + <kbd>Y</kbd>\n加粗：<kbd>Ctrl/Command</kbd> + <kbd>B</kbd>\n斜体：<kbd>Ctrl/Command</kbd> + <kbd>I</kbd>\n标题：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>H</kbd>\n无序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>U</kbd>\n有序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>O</kbd>\n检查列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd>\n插入代码：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>K</kbd>\n插入链接：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>L</kbd>\n插入图片：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>G</kbd>\n\n\n## 合理的创建标题，有助于目录的生成\n\n直接输入1次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成1级标题。\n输入2次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成2级标题。\n以此类推，我们支持6级标题。有助于使用`TOC`语法后生成一个完美的目录。\n\n\n\n## 如何改变文本的样式\n\n*强调文本* _强调文本_\n\n**加粗文本** __加粗文本__\n\n==标记文本==\n\n~~删除文本~~\n\n> 引用文本\n\nH~2~O is是液体。\n\n2^10^ 运算结果是 1024.\n\n\n\n## 插入链接与图片\n\n链接: [link](https://mp.csdn.net).\n\n图片: ![Alt](https://avatar.csdn.net/7/7/B/1_ralf_hx163com.jpg)\n\n带尺寸的图片: ![Alt](https://avatar.csdn.net/7/7/B/1_ralf_hx163com.jpg =30x30)\n\n当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。\n\n\n## 如何插入一段漂亮的代码片\n\n去[博客设置](https://mp.csdn.net/configure)页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 `代码片`.\n```javascrit\n// An highlighted block\nvar foo = 'bar';\n```\n\n\n## 生成一个适合你的列表\n\n- 项目\n  - 项目\n    - 项目\n\n1. 项目1\n2. 项目2\n3. 项目3\n\n- [ ] 计划任务\n- [x] 完成任务\n\n\n## 创建一个表格\n一个简单的表格是这么创建的：\n项目     | Value\n-------- | -----\n电脑  | $1600\n手机  | $12\n导管  | $1\n\n### 设定内容居中、居左、居右\n使用`:---------:`居中\n使用`:----------`居左\n使用`----------:`居右\n| 第一列       | 第二列         | 第三列        |\n|:-----------:| -------------:|:-------------|\n| 第一列文本居中 | 第二列文本居右  | 第三列文本居左 | \n\n\n### SmartyPants\nSmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：\n|    TYPE   |ASCII                          |HTML                         \n|----------------|-------------------------------|-----------------------------|\n|Single backticks|`'Isn't this fun?'`            |'Isn't this fun?'            |\n|Quotes          |`\"Isn't this fun?\"`            |\"Isn't this fun?\"            |\n|Dashes          |`-- is en-dash, --- is em-dash`|-- is en-dash, --- is em-dash|\n\n\n## 创建一个自定义列表\nMarkdown\n:  Text-to-HTML conversion tool\n\nAuthors\n:  John\n:  Luke\n\n\n## 如何创建一个注脚\n\n一个具有注脚的文本。[^2]\n\n[^2]: 注脚的解释\n\n\n##  注释也是必不可少的\n\nMarkdown将文本转换为 HTML。\n\n*[HTML]:   超文本标记语言\n\n\n## KaTeX数学公式\n\n您可以使用渲染LaTeX数学表达式 [KaTeX](https://khan.github.io/KaTeX/):\n\nGamma公式展示 $\\Gamma(n) = (n-1)!\\quad\\forall\nn\\in\\mathbb N$ 是通过欧拉积分\n\n$$\n\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.\n$$\n\n> 你可以找到更多关于的信息 **LaTeX** 数学表达式[here][1].\n\n\n## 新的甘特图功能，丰富你的文章\n\n```mermaid\ngantt\n        dateFormat  YYYY-MM-DD\n        title Adding GANTT diagram functionality to mermaid\n        section 现有任务\n        已完成               :done,    des1, 2014-01-06,2014-01-08\n        进行中               :active,  des2, 2014-01-09, 3d\n        计划一               :         des3, after des2, 5d\n        计划二               :         des4, after des3, 5d\n```\n- 关于 **甘特图** 语法，参考 [这儿][2],\n\n## UML 图表\n\n可以使用UML图表进行渲染。 [Mermaid](https://mermaidjs.github.io/). 例如下面产生的一个序列图：:\n\n```mermaid\nsequenceDiagram\n张三 ->> 李四: 你好！李四, 最近怎么样?\n李四-->>王五: 你最近怎么样，王五？\n李四--x 张三: 我很好，谢谢!\n李四-x 王五: 我很好，谢谢!\nNote right of 王五: 李四想了很长时间, 文字太长了<br/>不适合放在一行.\n\n李四-->>张三: 打量着王五...\n张三->>王五: 很好... 王五, 你怎么样?\n```\n\n这将产生一个流程图。:\n\n```mermaid\ngraph LR\nA[长方形] -- 链接 --> B((圆))\nA --> C(圆角长方形)\nB --> D{菱形}\nC --> D\n```\n\n- 关于 **Mermaid** 语法，参考 [这儿][3],\n\n## FLowchart流程图\n\n我们依旧会支持flowchart的流程图：\n```mermaid\nflowchat\nst=>start: 开始\ne=>end: 结束\nop=>operation: 我的操作\ncond=>condition: 确认？\n\nst->op->cond\ncond(yes)->e\ncond(no)->op\n```\n\n- 关于 **Flowchart流程图** 语法，参考 [这儿][4].\n\n\n## 导出与导入\n\n###  导出\n如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 **文章导出** ，生成一个.md文件或者.html文件进行本地保存。\n\n### 导入\n如果你想加载一篇你写过的.md文件或者.html文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入，\n继续你的创作。\n\n [1]: http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\n [2]: https://mermaidjs.github.io/\n [3]: https://mermaidjs.github.io/\n [4]: http://adrai.github.io/flowchart.js/","tags":["L·H"]}]